=== What is BEM?
This article describes the theory and practice of building web sites at a big company.

There are plenty of sites under development at Yandex, thousands in fact. The approaches
we use for HTML/CSS markup and other front-end technologies are in constant evolution.

Developing for a big portal has a range of specifics and the process should be able to accommodate them:

 * Fast-to-develop, long-lived projects\\
   It should be possible to develop and launch the first version quickly with an architecture that helps
   to maintain it in the long run.
 * Numerous people work on a project\\
   It should be possible to organize work efficiently in teams of 2 or more developers.
 * Team scalability\\
   Adding new people to a team has to improve its productivity. It should be possible to assign new members to a team
   without a steep learning curve.\\
   Code has to be well-structured for a project to remain maintainable over time and team changes.
 * Code reuse\\
   To maintain UI consistency and minimize development effort on typical interface components, said components have to be
   easily reusable.

For years we kept looking for solutions to our problems, and at one point they became
##BEM methodology##.\\
##BEM## means Block, Element, Modifier. The meaning of these terms is described further
in the article.

One of the most common examples of a methodology in  programming is Object-Oriented Programming.
This is a programming paradigm embodied by many languages. In many ways, BEM
is similar to OOP. It's a way of describing reality in code, a range of patterns, and
a way of thinking about program entities regardless of programming language in use.\\
We used BEM principles to create a set of front-end development techniques and tools which enable us 
to build pages quickly and maintain them for a long time.

The principles are the following:

=== Unified data domain
Imagine an ordinary website, like the one pictured below.

%%html
<div style="text-align:center">
<img src="images/site.png"/>
</div>
%%

When starting to develop such a site it is useful to mark out "blocks" of
which the site consists.\\
For example, in this picture there are ##Head##, ##Main Layout## and ##Foot## blocks. The
Head in turn consists of ##Logo##, ##Search##, ##Auth block## and ##Menu##. The Main
Layout contains ##Page Title## and ##Text Block##.

%%html
<div style="text-align:center">
<img src="images/site-marked.png"/>
</div>
%%

Giving each part of the page its own name is very useful when it comes to
team communication.\\
A manager could ask:
 * to make the ##Head## bigger or
 * to create one more page with a ##Head## without ##Search##

An HTML guy could ask a JavaScript developer
 * to make ##Auth Block## animated, etc.

Let's take a closer look at what constitutes BEM:

==== Block
A ##block## is an independent entity, a "building block" of an application. A block
can be either simple or compound (containing other blocks).

**Example**\\
Search form block\\

%%html
<div style="text-align:center">
<img src="images/search-block.png"/>
</div>
%%

====Element
An Element is a part of a block that performs a certain function. Elements are context-dependent: they only exist
inside blocks and are meaningless outside of them.

**Example**\\
An input field and a button are elements of the Search Block

%%html
<div style="text-align:center">
<img src="images/search-block-marked.en.png"/>
</div>
%%

===Means of describing pages and templates
Blocks and elements constitute a page content. Besides simply being present on the page,
their arrangement is also important.

Blocks (or elements) can follow each other in a certain order:

For example, a list of goods on a commerce website:

%%html
<div style="text-align:center">
<img src="images/goods-list.png"/>
</div>
%%

...or menu items:

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Blocks can also be contained inside other blocks:

For example, a ##Head Block## includes other blocks:

%%html
<div style="text-align:center">
<img src="images/head-marked.png"/>
</div>
%%

Besides our building blocks we need a way to describe page layout in plain text. To do so, each block
and element needs to have a keyword that identifies it.

A keyword designating a specific block is called ##block name##.

For example, ##menu## can be a key word for the ##Menu Block##, ##head## can be a keyword for the ##Head## block.

A key word designating an element is called ##element name##.

For example, each item in a menu is an element ##item## of the ##menu## block.

Block names must be unique within a project to unequivocally designate which block is being described.
Only instances of the same block can have same names. In this case we say that one block
is present on the page 2 (3, 4, ...) times.

Element names must be unique within the scope of a block. An element can be repeated several times. For example, menu items.

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Keywords should be put in certain order. Any data format which supports nesting (XML, JSON) will do:

%%hl xml
<b:page>
  <b:head>
    <b:menu>
      ...
    </b:menu>
    <e:column>
      <b:logo/>
    </e:column>
    <e:column>
      <b:search>
        <e:input/>
        <e:button>Search</e:button>
      </b:search>
    </e:column>
    <e:column>
      <b:auth>
        ...
      </b:auth>
    <e:column>
  </b:head>
</b:page>
%%

In this example ##b## and ##e## namespaces separate block nodes from element nodes.

The same in JSON:

%%hl js
{
  block: 'page',
  content: {
    block: 'head',
    content: [
      { block: 'menu', content: ... },
      {
        elem: 'column',
        content: { block: 'logo' }
      },
      {
        elem: 'column',
        content: [
          {
            block: 'search',
            content: [
              { elem: 'input' },
              {
                elem: 'button',
                content: 'Search'
              }
            ]
          }
        ]
      },
      {
        elem: 'column',
        content: {
          block: 'auth',
          content: ...
        }
      }
    ]
  }
}
%%

Examples above show an object model with blocks and elements nested inside each other. This structure can
also contain any number of custom data fields. We call this structure ##BEM tree## (by analogy with DOM tree).

Final browser markup is generated by applying template transformations (using XSL or JavaScript) to the BEM tree.

If a developer needs to move a block to a different place on the page, it's done by changing the BEM tree. Templates
generate the final view themselves.

In our recent products we went with JSON as a page description format. It is then turned into HTML by a JS-based template engine.\\
The tools we are using for that are described at the end of this article.

=== Block independence

As projects grow, blocks tend to be added, removed, or moved around the page. For example, you may want to swap
the ##Logo## and ##Auth Block## or to place the ##Menu## under ##Search Block##

%%html
<div style="text-align: center">
<img src="images/head.png"/>
</div>
%%

%%html
<div style="text-align: center">
<img src="images/head-changed.png"/>
</div>
%%

To make this process easier blocks must be ##independent##.

An ##independent## block is implemented in a way that allows arbitrary placement - anywhere on the page, including
nesting inside another block.

====Independent CSS

From the CSS point of view it means that

 * A block (or an element) must have a unique "name" (a class, usually) which can be used in a CSS rule.
 * There must be no CSS selectors for tags as they are inherently not context-free.
 * Cascading selectors for several blocks should be avoided.

=====Naming for independent CSS classes

One of the possible naming schemes for CSS classes, that satisfies said requirements, is the following:

 * CSS class for a block coincides with its ##block name##
%%hl xml
<ul class="menu">
  ...
</ul>
%%
 * CSS class for an element is a ##block name## and an ##element name## separated
 by some character(s)
%%hl xml
<ul class="menu">
  <li class="menu__item">
    ...
  </li>
  <li class="menu__item">
    ...
  </li>
</ul>
%%
It is necessary to include block's name in a CSS class for an element to minimize cascading.

Different naming schemes can be used, read ((http://bem.github.com/bem-bl/pages/naming/naming.eb.wiki here)) about
a naming convention we use.

====Independent templates

From the template engine's point of view, block independence means that:

 * Blocks and elements must be described in the template\\
   Blocks (or elements) must have unique "names" to be able to tell the template engine "Menu must be placed here".
 * Blocks can be placed in every place in the BEM tree

===== Independent templates for blocks
Coming upon a block in the template, the template engine should be able to unambiguously transform it into
HTML. Thus, every block should have a template for that.

For example, a template can look like this in XSL:
%%hl xml
<xsl:template match="b:menu">
  <ul class="menu">
    <xsl:apply-templates/>
  </ul>
</xsl:template>

<xsl:template match="b:menu/e:item">
  <li class="menu__item">
    <xsl:apply-templates/>
  </li>
<xsl:template>
%%

We are gradually discarding XSLT in our products in favor of our own JavaScript-based template engine
((https://github.com/veged/xjst XJST)). This template engine absorbs everything we like about XSLT,
but implements it with JavaScript's productivity on either client or server side.\\
We write our templates using a domain-specific language called BEMHTML, which is based on XJST.
((http://clubs.ya.ru/bem/replies.xml?item_no=992 The main ideas of BEMHTML)) are published
in BEM club on Ya.Ru (in Russian).

=== Blocks reiteration
The second ##Menu Block## can occur in the ##Foot block## of a site. Or one ##Text Block##
can turn into two separated by an advertisement.\\
Even if a block was developed as a singular unit, the same one can appear at any moment.

From the CSS viewpoint it means that:
 * ID-based CSS selectors should not be used\\
   It is convenient to use CSS classes

From the JavaScript viewpoint it means that:

 * The blocks with similar behaviour can be detected unequivocally: they have the same CSS classes\\
   Using CSS class selectors makes it possible to pick out all blocks with a given name and specify
   the required dynamic behaviour.

===Modifiers for elements and blocks
It is often needed to create a block which is very similar to an existing block, but with slight changes to
its looks or behavior.\\
E.g. there is a task:
 * Create one more ##Menu## in the ##Footer## with //another layout//.

%%html
<div style="text-align: center">
<img src="images/site-footer-menu.png"/>
</div>
%%

To avoid developing a block that is only very slightly different from an existing one, we can use a
##modifier##.

A ##modifier## is a property of a block or an element which alters its looks or behavior.\\
A modifier has a name and a value. Several modifiers can be used at once.

**Example**\\
A block's modifier specifies background color

%%html
<div style="text-align: center">
<img src="images/search-background.png"/>
</div>
%%

**Example**\\
An element's modifier changes the looks of a "current" item

%%html
<div style="text-align: center">
<img src="images/menu-current-item.png"/>
</div>
%%

From the template point of view:
 * In the BEM tree, modifiers are properties of the entity that describes a block or an element

For example, they can be node attributes in XML:

%%hl xml
<b:menu m:size="big" m:type="buttons">
  ...
</b:menu>
%%

The same expressed using JSON:

%%hl js
{
  block: 'menu',
  mods: [
   { size: 'big' },
   { type: 'buttons' }
  ]
}
%%

From the CSS point of view:
 * A modifier is an additional CSS class for a block or an element.

%%hl xml
<ul class="menu menu_size_big menu_type_buttons">
  ...
</ul>
%%

%%hl js
.menu_size_big {
  // CSS code to specify height
}
.menu_type_buttons .menu__item {
  // CSS code to change item's looks
}
%%

Element modifiers are implemented in the same fashion.

E.g. current menu item can be marked with a modifier:

%%hl xml
<b:menu>
  <e:item>Index<e:item>
  <e:item m:state="current">Products</e:item>
  <e:item>Contact<e:item>
</b:menu>
%%

%%hl js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'Index' },
    {
      elem: 'item',
      mods: { 'state' : 'current' },
      content: 'Products'
    },
    { elem: 'item', content: 'Contact' }
  ]
}
%%

%%hl xml
<div class="menu">
  <ul class="menu__layout">
    <li class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </li>
  </ul>
</div>
%%

%%hl js
.menu__item_state_current {
  font-weight: bold;
}
%%

=== Subject abstraction
If there are many people who work for a project, they should arrange for a data domain. All the bloks
of a project must have definite names used in code.

E.g. a block ##Tag Cloud## is always called ##tags##. Each of its element is a ##tag##. This is right for
every language: CSS, JavaScript, XSL, etc.

From the development process' point of view:
 * All the participants operate with the same terms

From the viewpoint of CSS:
 * CSS for blocks and elements can be written in a pseudo language which then is compiled
   into a pure CSS according to the naming convention.

%%hl js
  .menu {
    __layout {
      display: inline;
    }
    __layout-item {
      display: inline-block;
      ...
    }
    __item {
      _state_current {
        font-weight: bold;
      }
    }
  }
%%

From the JavaScript's point of view:
 * Do not use CSS class selector to get a block's or an elements' DOM object.

%%hl js
$('menu__item').click( ... );
$('menu__item').addClass('menu__item_state_current');
$('menu').toggle('menu_size_big').toggle('menu_size_small');
%%

The naming convention for CSS classes of blocks and elements can be changed. Using special JavaScript
functions for an access to the blocks and the elements and in order to work with their modifiers makes it possible
to change these functions only.

%%hl js
Block('menu').elem('item').click( ... );
Block('menu').elem('item').setMod('state', 'current');
Block('menu').toggleMod('size', 'big', 'small');
%%

The code above is abstract. In our real products we use a JavaScript core of ##i-bem## block
from ##bem-bl## block library:
 ((http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html))

=== A block's consistency
A site has a ##Button## block which has its dymanic behaviour.

%%html
<div style="text-align: center">
<img src="images/button.png"/>
</div>
%%

When a cursor hovers on the block, it changes its appearance.

%%html
<div style="text-align: center">
<img src="images/button-cursor.png"/>
</div>
%%

A manager could ask:
 * to use the same button on another page

The CSS implementation of the block is insufficient. In this case to reiterate the block we must
reiterate its behaviour which is described in JavaScript as well.

So a block must "know" everything about itself. That is a block's implementation. This means that
its view and behaviour is realized in all the technologies needed. That we call ##multilengualism##.

##Multilingualism## is a description of a block in all the programming languages which are neccessary for
its functionality.

If a block has to be viewed on a page, it has to have the following techs:
 * templates (XSL, TT2, JavaScript, etc), which turn block's declaration into page's HTML code
 * CSS that describes a block's view

If a block has a dynamic behaviour, we add it to this list:
 * a JavaScript implementation for the block

Everything that concern the block is its technology. E.g.:
 * A block's images

=== File system representation for a block
==== Unequivocal place of code
===== File naming
If a project
 * lives long and it's always acquiring new features

If a  developing team
 * consists of several people
 * grows and changes (new people appear)

All this in turn mean that needs a way to find block's code files fast.

A block's code is easy to find if it's placed in files with the same name as a block key
word is:

%%html
<pre>
menu.xsl
menu.js
menu.css
</pre>
%%

===== File independence of a block
There could be a task
 * to use some blocks from a previous project for a new one

For doing it easily we have to be able to deliver a block's implementation (in all its techs)
to another place. This can be done by file copying or partial checkout of a repo from a 
donor project. In both these cases it is useful if all block's files are gathered in the same
directory:

%%html
<pre>
menu/
  menu.xsl
  menu.js
  menu.css
</pre>
%%

===== File structure of a block
When working on a project there can appear a necessity to change a block.

A manager could ask:
 * to change a color of a ##Current Menu Point##
or
 * to make a ##Menu## reacting on cursor's hovering

One developer could ask another:
 * to help with ##Search Form## markup for IE

To understand where is the code discussed we have to follow these rules when developing:
 * A block's code is placed in a separate directory
   * The directory's name coincides with the blocks' name
   * The block's technical implementation is placed in the files in block's directory
 * An element has a subdirectory in its block's directory
   * The subdirectory's name coincides with the element's name
   * The technical implementation of an element is placed in the files in this subdirectory
 * A modifier has a subdirectory in its block's directory
   * The subdirectory's name coincides with the modifier's name
   * The technical implementation of the modifier is placed in the files in this subdirectory
   * A file name includes both a key and a value of a modifier

**Example**\\
A file structure of a ##Menu## block

%%html
<pre>
menu/
  __item/
    _state/
      menu__item_state_current.css
      menu__item_state_current.xsl
    menu__item.css
    menu__item.xsl
  menu.css
  menu.js
  menu.xsl
</pre>
%%

Maintaining this file structure manually is not convenient. So we use
((https://github.com/bem/bem-tools BEM tools))
to work with files. These are a range of utilities that enable us to create
files with certain names, file place and a content.

===== Grouping blocks in directories
A big portal needs to have the same block in different sites.

There could be a task:
 * to create the same ##Footer## on //all the portal's services// or
 * to create a //new project// using the blocks for existing ones

Developing for a web design company, often means that onr has to use typical solutions
for typical web pages.

A manager could ask:
 * to create an order page with a web form //as on previous project//

We have to do these tasks and avoid to copy blocks' files from project to project. There needs be
an opportunity to link up the blocks from one project to another. Blocks have to be united in
one directory for that.

We call such a directory ##blocks##.

**E.g.**

%%html
<pre>
blocks/
  foot/
  head/
  menu/
  page/
  search/
</pre>
%%

That directory can be linked up to another project straight from a repo. So a block's code is kept
in one place. If we need to correct something or to make other changes, we do it in one
place only.

==== Levels of definition
If a group of blocks (united in one directory) is linked up to a project directly (via a partial checkout
or svn:externals), then every changing committed for these blocks influences to both projects.

When developing a site based on another existing one it may need:
 * to enlarge a font in ##Head## on a site (without affecting the previous site),
 * to add an animation when showing a dropdown menu.

Then there is a need to define or redefine blocks in different technologies for
one site only or for certain pages only. It is owed to ##defining levels##.

A ##defining level## is a set of blocks' implementations grouped in one directory.

%%html
<div style="text-align:center;">
<img src="images/levels-schema.png"/>
</div>
%%

An implementation of every block from a library can be expanded (or redefined) at a project's level.

%%html
<div style="text-align:center;">
<img src="images/block-levels.png"/>
</div>
%%

From the viewpoint of the process of building a page:
 * When building a page we can set a list of levels (directories) to use their blocks on
   the page. E.g.,
   ##build-page -l blocks-common -l blocks-my my-page.html##

From the file structure's point of view:
 * A project can have any number of levels. But only the levels that are enumerated when builing
   will be on the page. It is possibly to make different sets of defining levels
   for different parts of the site.

From the JavaScript's point of view:
 * There is need to define a dynamic behaviour of a page in a declarative style.
   Final behaviour has to be gathered from different defining levels. E.g.,

%%hl js
/* blocks-common/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    ...
  }
});

/* blocks-my/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    this.__base();
    ...
  }
});
%%

From the viewpoint of a template engine:
 * To be able not only to define but to redefine a template one needs to
   apply previous implementation for a template.\\
   E.g., for XSL:

%%hl xml
<xsl:template match="b:head">
  <div> <!-- Node for extra design -->
    <xsl:apply-imports/>
  </div>
</xsl:template>
%%

From a project architecture's point of view:
 * When developing a portal of several sites we can sort out a blocks library which is one of
   defining levels for all the sites of the portal. And the blocks for a concrete site
   can be united in another level.
 * The same repo can have blocks of both desktop and mobile browsers.\\
   Such a project has defining levels of common blocks, mobile blocks and desktop blocks.
   Different combinations of these levels give the implementation needed on concrete
   pages.


((https://github.com/bem/bem-bl Open source block library bem-bl)) can be an example of
having several defining levels in one repo.

=== Building a page
Working in terms of blocks means that there exists ##subject abstraction##. This is obligatory only when
a programmer work with code. When code gets to a browser subject abstraction is
not necessary. It is important only to save a design and behaviour of every block on the page.

So, there is a ##code for people## and a ##code for browsers##. They are not the same one.
 * A programmer writes a code for blocks, a browser gets a code for the whole page

To turn a ##code fo people##  into ##code for a browser## we ##build## a page.

##Building a page## is making a page's code in different technologies (HTML, CSS, JavaScript)
based on a page declaration (XML or JSON) by applying implementations of the blocks declared

From the CSS' point of view:

 * The block files are gathered in one page file\\
   Despite the fact that CSS for every block, element or modifier is placed in a separate
   file, there is no need to link up these files to the page as is. It is possible to
   collect all the CSS implementation needed in one file.\\
   In addition that solves the problem of limitation for CSS imports in IE and descreases
   the number of HTTP requests.
   We use the ((https://github.com/veged/borschik borschik)) tool to unite all CSS in one
   file.
 * A browser gets minimized code\\
   When building we can minimize and optimize a CSS code. E.g. using the
   ((https://github.com/afelix/csso CSSO)) utility.
 * Each browser can get a CSS code written especially for it\\
   There is a possibility to divide CSS implementations for different browsers and deliver
   only the code needed for each browser.\\
   A ((https://github.com/afelix/setochka setochka, a prototype)) can be used for that.

From the JavaScript's point of view:
 * There are many files for blocks, and there is one file for a page\\
   The same as in the CSS' case, a JavaScript implementation of all the blocks
   needed can be united in one file.

From the template engine's point of view:
 * Only needed templates work\\
   A final set of templates that is used for creating an HTML for a page has only the templates
   for the blocks required. Because of that a template productivity increases and the probability
   of appearing side effects is diminished.

From the viewpoint of developing process:
 * Robots serve for people (not counterwise)\\
   A developer writes a code in an easy way. "Robots" take care of the productivity by optimizing the
   code (and probably making it unreadable) when building a page.

From the viewpoint of labor organization
 * Division of labour\\
   There are developers to create blocks. And there are developers to optimize the final product.

We use ((https://github.com/bem/bem-tools BEM tools)) to build pages.

== Related links
==== Libraries
 * ((http://bem.github.com/bem-bl/index.en.html An open source block library bem-bl))
==== Tools
 * ((https://github.com/bem/bem-tools Tools for working with files accroding to BEM methodology))
 * ((https://github.com/veged/borschik Borschik))\\
   An utility to build static files into one.
 * ((https://github.com/afelix/setochka Setochka, a prototype))\\
   A tool to divide CSS in several browser-oriented files.
 * ((https://github.com/afelix/csso CSSO))\\
   A utility that optimizes a CSS code with a glance of its structure.
==== Supplement information
 * ((http://clubs.ya.ru/bem/posts.xml?tag=64664080 Presentations and workshops video)) (russian speaking)
 * ((http://clubs.ya.ru/bem/ BEM club at Ya.Ru)) (russian speaking)
