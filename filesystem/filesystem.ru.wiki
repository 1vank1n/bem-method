== Представление блоков на файловой системе
=== Однозначное положение кода
==== Именование файлов
Если проект
 * живёт долго и постоянно обрастает новыми сущностями

Если команда разработки
 * состоит из нескольких специалистов
 * растёт и изменяется (появляются новые люди)

нужен способ быстро определять, где может находиться код блока.

Код блока легко искать, если он расположен в файлах, одноимённых ключевому слову блока:

%%html
<pre>
menu.xsl
menu.js
menu.css
</pre>
%%

==== Файловая независимость блока
Может возникнуть задача использовать несколько блоков предыдущего проекта на новом проекте.

Чтобы легко делать это, реализацию блока (во всех технологиях) нужно уметь доставлять в
другое место. Это может быть сделано при помощи копирования файлов или частичным чекаутом
репозитория проекта-донора.

И в том, и в другом случае удобно, чтобы все файлы, относящиеся к блоку, были объединены
в одну директорию:

%%html
<pre>
menu/
  menu.xsl
  menu.js
  menu.css
</pre>
%%

==== Файловая структура блока
В процессе работы над проектом может возникнуть необходимость изменить какой-нибудь блок.

Менеджер может попросить:
 *  Изменить цвет ##активному пункту Меню##, или
 *  Сделать ##Меню## реагирующим на наведение курсора

Один разработчик может попросить другого:
 *  Помочь с вёрсткой ##Поисковой формы## под IE

Чтобы можно было сразу понять, где лежит код, о котором идёт речь, нужно соблюдать в
разработке следующие требования:
 * Код блока размещён в отдельной директории
   * Имя директории совпадает с именем блока
   * Техническая реализация блока размещена в файлах в директории блока
 * Элементу соответствует поддиректория в директории блока
   * Имя директории совпадает с именем элемента
   * Техническая реализация элемента располагается в файлах в этой директории
 * Модификатору соответствует поддиректория в директории блока
   * Имя директории соответствует имени модификатора
   * Техническая реализация модификатора размещается в файлах в этой директории
   * Названия файлов содержат как имя, так и значение модификатора

**Пример**\\
Файловая структура блока Меню

%%html
<pre>
menu/
  __item/
    _state/
      menu__item_state_current.css
      menu__item_state_current.xsl
    menu__item.css
    menu__item.xsl
  menu.css
  menu.js
  menu.xsl
</pre>
%%

Поддерживать такую файловую структуру вручную неудобно. Для работы с файлами мы используем
((https://github.com/bem/bem-tools БЭМ-инструменты)). Это набор утилит, позволяющий создавать
файлы по определённым шаблонам и с определённой схемой расположения на файловой системе.

==== Группировка блоков в папки
На большом портале необходимо реализовывать одни и те же блоки на разных проектах.

Может возникнуть задача:
 * Реализовать одинаковый Подвал ##на всех проектах Портала##, или
 * Сделать  ##новый проект##, используя блоки уже существующего

Разработка сайтов один за другим в web-студии часто подразумевает использование типовых решений для типовых страниц.

Менеджер может попросить:
 * Сделать Страницу заказа товара с формой ##как на позапрошлом проекте##

Выполнять эти задачи нужно без копирования блоков из проекта в проект. Должна быть возможность
подключить блоки одного проекта к другому. Для этого блоки нужно объединять в одну директорию.

Мы называем такую директорию ##blocks##.

**Пример**

%%html
<pre>
blocks/
  foot/
  head/
  menu/
  page/
  search/
</pre>
%%

Такую папку можно подключить к новому проекту прямо из репозитория. Так, код блока будет храниться
только в одном месте. Если нужно исправить ошибку или внести другие изменения, это нужно будет сделать только там.

=== Уровни переопределения
Если группа блоков одного проекта (объединённая в папку) подключена к другому проекту напрямую
(при помощи частичного чекаута или svn:externals), то любое закоммиченное изменение в таких блоках
повлияет на оба проекта.

При разработке одного сайта на основе существующего может потребоваться:
 * Увеличить шрифт в Шапке на всём сайте (не затрагивая предыдущий сайт),
 * Добавить анимацию для раскрытия всех выпадающих меню.

То есть необходима возможность переопределять (или доопределять) блоки в разных технологиях только
для определённого сайта или только для определённых страниц. Это возможно благодаря ##уровням переопределения##.

##Уровень переопределения## — это набор реализаций блоков, сгруппированных в одну директорию.

%%html
<div style="text-align:center;">
<img src="images/levels-schema.png"/>
</div>
%%

Реализация любого блока библиотеки может быть расширена (или переопределена) на уровне проекта.

%%html
<div style="text-align:center;">
<img src="images/block-levels.png"/>
</div>
%%

С точки зрения сборки страниц:
 * При сборке каждой страницы можно указать список уровней (директорий), блоки которых будут
   представлены на странице. Например,\\
   ##build-page -l blocks-common -l blocks-my my-page.html##

С точки зрения файловой структуры:
 * Проект можно содержать любое количество реализаций блоков. Но на страницу попадут только те,
   которые явно указаны к применению для сборки этой страницы. Возможно делать разные наборы
   уровней переопределения для разных разделов сайтов.

С точки зрения JavaScript
 * Необходима возможность декларативного описания динамического поведения элементов на странице.
   Конечное поведение должно собираться с разных уровней переопределения. Например,

%%hl js
/* blocks-common/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    …
  }
});

/* blocks-my/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    this.__base();
    …
  }
});
%%

С точки зрения шаблонного движка
* Для того, чтобы можно было не только переопределять, но и "доопределять" шаблон, нужна
   возможность вызвать предыдущую реализацию шаблона.\\
   Например, в случае xsl:

%%hl xml
<xsl:template match="b:head">
  <div> <!-- Node for extra design -->
    <xsl:apply-imports/>
  </div>
</xsl:template>
%%

С точки зрения архитектуры проекта
 * При разработке портала из нескольких сайтов можно выделить общую библиотеку блоков, которая станет
   одним из уровней переопределения для всех сайтов портала. Блоки конкретного сайта — объединить в
   другой уровень переопределения.
 * В одном и том же репозитории может храниться реализация сайта для десктопных и мобильных браузеров.\\
   В таком проекте есть уровень переопределения для общей реализации блоков, для мобильной и для десктопной.
   Различные комбинации уровней дают желаемую реализацию блоков на конкретных страницах.

Примером реализации нескольких уровней переопределения в одном репозитории может служить
((https://github.com/bem/bem-bl Open Source библиотека блоков bem-bl)).

=== Сборка страниц
Работа со страницей в терминах блоков подразумевает ##предметную абстракцию##. Эта предметная абстракция
обязательна только на уровне взаимодействия человека с кодом. Когда код попадает в браузер, наличие
предметной абстракции не обязательно, важно лишь сохранить требуемый внешний вид и поведение блоков на странице.

Таким образом, ##код для людей## и ##код для браузеров## — не одно и то же:
 * Человек пишет код блоков, браузер получает код целой страницы

Для того, чтобы превратить "код для людей" в "код для браузеров", существует понятие ##сборки страниц##.

##Сборка страницы## — это формирование кода страницы в различных технологиях
(HTML, CSS, JavaScript) на основе декларативного описания страницы (XML, JSON)
путём применения реализаций описанных блоков.

С точки зрения CSS

 * Файлы всех блоков собираются в один файл страницы\\
   Несмотря на то, что CSS для каждого блока, элемента и модификатора реализован в отдельном файле,
   для работы страницы нет необходимости подключать эти файлы as is. Всю необходимую CSS-реализацию
   страницы можно собрать в один файл. К тому же это решает проблемы: ограниченного количества импортов
   в IE, количества HTTP-запросов к серверу. Объединение всех CSS в один файл мы делаем при помощи
   утилиты ((https://github.com/veged/borschik borschik)).
 * Браузер получает минимизированный код\\
   В процессе сборки можно минимизировать и оптимизировать CSS-код. Например, при помощи утилиты
   ((https://github.com/afelix/csso CSSO))
 * Каждый браузер получает CSS, написанный специально для него\\
   Есть возможность разделять CSS-реализации для разных браузеров и поставлять в каждый конкретный
   браузер только тот CSS, который нужен ему. Для этого можно использовать ((https://github.com/afelix/setochka Сеточку, прототип))

С точки зрения JavaScript
 * Много файлов для блоков, один файл для страницы\\
   Так же, как и в случае CSS, JavaScript-реализация всех необходимых блоков может быть объединена в один файл.

С точки зрения шаблонных движков
 * Работают только нужные шаблоны\\
   Конечный набор шаблонов, используемых для вывода HTML страницы в результате сборки содержит только
   шаблоны нужных блоков. Благодаря этому увеличивается производительность шаблонов и  уменьшается
   вероятность возникновения побочных эффектов.

С точки зрения процесса разработки
 * Роботы на службе у человека (не наоборот)\\
   Разработчик пишет код так, как ему удобно. О производительности заботятся роботы, которые в процессе
   сборки превращают код в оптимизированный (и, возможно, нечитаемый).

С точки зрения организации труда
 * Разделение труда\\
   Существуют одни разработчики, создающие блоки, и существуют другие разработчики, занимающиеся
   оптимизацией конечного продукта.

Для сборки файлов страниц используются ((https://github.com/bem/bem-tools БЭМ-инструменты)).

==== Автоматизация сборки
Использование ((https://github.com/bem/bem-tools БЭМ-инструментов)) подразумевает выполнение
нескольких операций для каждой страницы. В результате этих операций на основе bemjson описания
страницы генерируются CSS и JavaScript файлы страницы, шаблоны страницы и (в случае статической разработки)
- HTML страницы.

Чтобы не выполнять эти команды вручную, для проекта на БЭМ методе обычно пишут ((http://www.gnu.org/software/make/manual/make.html GNUmakefile))
с инструкциями по сборке страниц.\\
Пример такого файла можено найти в тестовом проекте ((https://github.com/bem/bem-bl-test/blob/master/GNUmakefile bem-bl-test)).

Однако, использование GNU make имеет ряд проблем:

 * нужно его запускать руками каждый раз после редактирования;
 * из-за того, что при каждом запуске gmake заново перечитывает информацию с диска, компиляция не очень быстрая;
 * т.к. по нашей методологии наличие/отсутсвие файла на диске имеет значение, мы не можем выразить
зависимости с помощью отношений цель-пререквизит.

Мы хотим сделать нечто, что заменит нам GNU make в процессе сборки страниц. Это
будет одновременно и сервер для разработки и способ статически собрать файлы для продакшена.
##bem server## будет запускаться в корне проекта и отвечать по http на-лету собираемыми файлами
(т.е. не нужно запускать gmake вручную после каждого изменения).\\
Кроме того, он сможет с помощью ((http://nodemanual.org/latest/nodejs_ref_guide/fs.FSWatcher.html fs.FSWatcher))
следить за изменением, появлением и удалением файлов, что позволит эффективнее кешировать
результаты сборок до момента, когда они потеряют актуальность.

##bem server## -- это одна из комманд ((https://github.com/bem/bem-tools bem-tools)), в нынешней версии
она умеет запускать HTTP-сервер, накладывать ##bemhtml##-шаблоны на ##bemjson##-описание страницы и
инлайнить import`ы в CSS-файлах при помощи ((https://github.com/veged/borschik утилиты borschik)).\\
Подробности можно прочесть в ((http://clubs.ya.ru/bem/replies.xml?item_no=1261 анонс на Я.ру)).

