## Что такое БЭМ?
`БЭМ` расшифровывается как Блок-Элемент-Модификатор, смысл этих терминов раскрыт
ниже.

Один из самых распространённых примеров методологии в программировании – это ООП.
ООП – парадигма программирования, применимая во многих языках. Точно так же и методология
БЭМ – способ описания действительности в коде, набор паттернов и способ думать о
сущностях вне зависимости от того, на каком языке программирования это реализуется.

На основе этой методологии разработаны подходы к вёрстке и технические решения,
которые позволяют нам быстро создавать новые страницы и легко поддерживать уже
существующие.

### Единая предметная область
Представьте обычный сайт. Например, такой, как на картинке.

![Обычный сайт](http://img-fotki.yandex.ru/get/9347/221798411.0/0_babd8_4e505a88_XXL.png)

При разработке и развитии сайта удобно мысленно выделить «блоки», из которых сайт состоит.

Например, на этом макете есть `Шапка`, `Основной лайаут` и `Подвал`. Шапка в свою
очередь состоит из `Логотипа`, `Поиска`, `Блока авторизации` и `Меню`. Основной
лайаут содержит `Заголовок страницы` и `Блок текста`.

![Блоки сайта](http://img-fotki.yandex.ru/get/9258/221798411.0/0_babd7_c4c0b5d6_XXL.png)

Если у каждой части сайта есть название, этими терминами удобно пользоваться при общении
внутри команды.

Менеджер может попросить
 * увеличить `Шапку`, или
 * Сделать ещё одну страницу, где в `Шапке` нет `Поиска`

Можно попросить JavaScript-разработчика
 * Сделать `Блок авторизации` анимированным, и т.д.

Итак,

#### Блок
Мы называем блоком некоторую самостоятельную сущность, кирпичик проекта.
Блок может быть простым или составным, то есть содержать в себе другие блоки.

**Пример**  
Блок поисковой формы

![Блок поисковой формы](http://img-fotki.yandex.ru/get/9316/221798411.0/0_babd5_c3d7b2b5_XL.png)

#### Элемент
Элемент – это часть блока, отвечающая за отдельную функцию.
Он может находиться только в составе блока и не имеет смысла в отрыве от него.

**Пример**  
Поле ввода и кнопка — элементы поискового блока

![Поле ввода и кнопка](http://img-fotki.yandex.ru/get/9515/221798411.0/0_babd4_efd80a69_XXL.png)

### Cредства описания страницы и шаблоны
Блоки и элементы – это обозначение содержания страницы. Помимо факта присутствия
конкретных блоков на странице, важно также их расположение.

Блоки (или элементы) могут идти друг за другом в определённом порядке.

Например, товары в интернет-магазине:

![Товары в интернет-магазине](http://img-fotki.yandex.ru/get/9109/221798411.0/0_babcc_d935a8ec_XXL.png)

Или пункты меню:

![Пункты меню](http://img-fotki.yandex.ru/get/6726/221798411.0/0_babd1_f14000fa_XL.png)

Блоки могут быть вложены друг в друга.

Например, блок Шапка содержит другие блоки:

![Составляющие блока Шапка](http://img-fotki.yandex.ru/get/5008/221798411.0/0_babce_7deef28f_XXL.png)

Чтобы быстро изменять содержание страницы, добавлять новые блоки, перемещать их друг
относительно друга, нужен способ описания страницы в виде текста. Для этого необходимо,
чтобы каждому блоку или элементу соответствовало ключевое слово.

Ключевое слово, обозначающее конкретный блок, называется `именем блока`.

Например, `menu` для меню или `head` для шапки сайта.

Ключевое слово, обозначающее элемент, называется `именем элемента`.

Например, каждый пункт меню – это элемент `item` блока `menu`.

Имя блока должно быть уникальным, из него однозначно следует, о каком блоке идёт речь.
Одинаковые имена могут быть только у одинаковых блоков. В этом случае мы говорим о том,
что один блок представлен на странице 2 (3, 4, …) раза.

Имя элемента должно быть уникальным только в пределах блока.
Элемент может повторяться в блоке несколько раз.

Например, пункты меню:

![Пункты меню](http://img-fotki.yandex.ru/get/6726/221798411.0/0_babd1_f14000fa_XL.png)

Такие ключевые слова нужно размещать в определённом порядке. Для этого подойдут форматы
данных с использованием вложенности. Например, XML или JSON:

```xml
<b:page>
  <b:head>
    <b:menu>
      …
    </b:menu>
    <e:column>
      <b:logo/>
    </e:column>
    <e:column>
      <b:search>
        <e:input/>
        <e:button>Search</e:button>
      </b:search>
    </e:column>
    <e:column>
      <b:auth>
        …
      </b:auth>
    </e:column>
  </b:head>
</b:page>
```

В данном примере пространства имён `b` и `e` использованы, чтобы отделять узлы блоков от узлов элементов.

То же самое в JSON:

```js
{
  block: 'page',
  content: {
    block: 'head',
    content: [
      { block: 'menu', content: … },
      {
        elem: 'column',
        content: { block: 'logo' }
      },
      {
        elem: 'column',
        content: [
          {
            block: 'search',
            content: [
              { elem: 'input' },
              { elem: 'button', content: 'Search' }
            ]
          }
        ]
      },
      {
        elem: 'column',
        content: {
          block: 'auth', content: …
        }
      }
    ]
  }
}
```

На примерах выше приведена объектная модель с вложенностью блоков и элементов в другие
блоки. Также в описании страницы присутствуют произвольные данные.

Такую структуру мы называем `БЭМ-деревом` (по аналогии с DOM-деревом).

Конечный HTML для браузера получается из БЭМ-дерева страницы путём наложения шаблонов
(например, XSL-шаблоны или JavaScript).

Если разработчику нужно переместить блок в другое место на странице, это делается при
помощи изменения дерева. Конечный вид шаблоны сделают сами.

Вы можете использовать любой формат для описания БЭМ-дерева и любой шаблонизатор.

Мы ориентируемся на JSON как формат описания страницы.
Он превращается в HTML при помощи JavaScript-based шаблонизатора BEMHTML.

### Независимость блоков
Во время разработки или поддержки долгоживущего проекта может возникнуть желание
переместить блок. Например, стоит задача

 * Поменять местами `Логотип` и `Блок авторизации`, или
 * Разместить `Меню` под `Поиском`

![Смена положения блоков](http://img-fotki.yandex.ru/get/9110/221798411.0/0_babcf_819f07f2_XXL.png)

![Смена положения блоков](http://img-fotki.yandex.ru/get/9153/221798411.0/0_babcd_313420f0_XXL.png)

Для того, чтобы легко выполнять эти просьбы, блоки должны быть `независимыми`.

`Независимый` блок реализован так, чтобы его можно было вставить в любое место на странице.
В том числе и вставить в другой блок.

#### Независимый CSS
С точки зрения CSS для блока это означает, что

 * У блока (или элемента) должно быть уникальное «имя», на которое можно написать CSS
   правило. Например, соответствующий CSS-класс.
 * Не должно быть CSS-селекторов на теги (`.menu td`), они по определению контекстно-зависимые
 * Нужно избегать каскадные селекторы

##### Пример схемы именования независимых CSS-классов
Одна из возможных схем именования CSS-классов, удовлетворяющая требованиям, такая:

 * CSS-класс блока совпадает с `именем блока`

```xml
<ul class="menu">
  …
</ul>
```
 * CSS-класс элемента — это `имя блока` и `имя элемента`, разделённые
 определённым символом (или символами)

```xml
<ul class="menu">
  <li class="menu__item">…</li>
  <li class="menu__item">…</li>
</ul>
```

Необходимость учитывать имя блока в CSS-классе для элемента нужна для минимизации каскада.

Так же важно использовать одинаковые разделители для облегчения написания инструментов
(описанных ниже) для программного доступа к элементам.

Мы используем дефис для разделения слов в длинных именах (например, `block-name`) и два
подчёркивания для отделения имени блока от имени элемента (`block-name_~_element-name`).

Но вы можете использовать другую схему отделения слов в именах и отделения имени блока от
имени элемента.

Например:
  * `block-name-~-element-name` или
  * `blockName-elementName`

####Независимые шаблоны
С точки зрения шаблонного движка независимость блоков означает, что:

 * Блоки и элементы должны иметь описание во входных данных  
    У блока (или элемента) должно быть уникальное «имя», чтобы при передаче данных шаблонному движку
    можно было сказать «здесь нужно разместить Меню».
 * Блок может быть легко помещён в любое место в БЭМ-дереве

##### Пример независимых шаблонов для блоков
Встречая во входных данных описание блока, шаблон должен однозначно преобразовывать его в
нужный HTML. Для этого у каждого блока должен быть свой шаблон.

Например, в XSL это может выглядеть так:

```xml
<xsl:template match="b:menu">
  <ul class="menu">
    <xsl:apply-templates/>
  </ul>
</xsl:template>

<xsl:template match="b:menu/e:item">
  <li class="menu__item">
    <xsl:apply-templates/>
  </li>
<xsl:template>
```

В своих собственных разработках мы постепенно отказываемся от XSL в пользу собственного
JavaScript-based шаблонного движка [XJST](https://github.com/veged/xjst). Этот шаблонизатор вобрал в
себя всё то, что нам нравилось в XSL, но реализует это с производительностью JavaScript как на
сервере, так и на клиенте.

Мы пишем шаблоны для блоков на предметно-ориентированном языке (domain specific language) BEMHTML, в
основе которого лежит XJST.
[Основные понятия шаблонизатора BEMHTML](/libs/bem-core/1.0.0/bemhtml/rationale/).

### Повторяемость блоков
На сайте может появиться второй блок `Меню`, например, в `Подвале`. Или два блока `Текст`,
разделённых рекламной вставкой.

Даже если блок проектировался как единственный, на странице в любой момент может появиться второй
такой же.

С точки зрения CSS это обозначает, что:
 * Для CSS-селекторов не используются селекторы с ID
    Вместо них удобно использовать классы

С точки зрения JavaScript это обозначает, что:
 * Блоки, которым требуется одинаковое поведение, могут быть однозначно определены: у них
одинаковый CSS-класс
    Используя селекторы класса, можно выбрать все одинаковые блоки на странице и задать им нужное
    динамическое поведение.

### Модифицируемость блоков
Может возникнуть ситуация, в которой требуется не просто повторить блок, но и внести в него
незначительные изменения.

Например, стоит задача:
 * Сделать в подвале ещё одно меню, с *другим дизайном*.

![Добавить меню в подвале](http://img-fotki.yandex.ru/get/9255/221798411.0/0_babd6_ec71b7f8_XXL.png)

Чтобы не разрабатывать блок, минимально отличающийся от уже существующего,
нужно воспользоваться `модификатором`.

`Модификатор` — это свойство блока или элемента, которое меняет внешний вид или поведение.

Модификатор имеет имя и значение. Одновременно может использоваться несколько разных модификаторов.

**Пример**  
Модификатор блока задаёт ему цвет фона

![Смена фона блока](http://img-fotki.yandex.ru/get/9325/221798411.0/0_babd2_7da50c7b_XL.png)

**Пример**  
Модификатор элемента для текущего пункта меню изменяет его внешний вид

![Смена внешнего вида блока](http://img-fotki.yandex.ru/get/9313/221798411.0/0_babd0_503ecad_L.png)

#### С точки зрения входных данных
В БЭМ-дереве модификаторы представлены как свойства той сущности, которая описывает блок или элемент.

Например, в XML это могут быть атрибуты соответствующего узла:

```xml
<b:menu m:size="big" m:type="buttons">
  …
</b:menu>
```

То же самое в формате JSON:

```js
{
  block: 'menu',
  mods: [
    { size: 'big' },
    { type: 'buttons' }
  ]
}
```

#### C точки зрения HTML/CSS
Модификатор представляется дополнительным CSS-классом блока или элемента.

```xml
<ul class="menu menu_size_big menu_type_buttons">
  …
</ul>
```

```css
.menu_size_big {
  // CSS code to specify height
}
.menu_type_buttons .menu__item {
  // CSS code to change item's look
}
```

Мы используем одно подчёркивание для отделение имени модификатора от имени блока и
ещё одно подчёркивание для отделения значения модификатора от его имени.

### Модифицируемость элементов
Модифицируемость элементов реализуется по аналогии.

Обращаем ещё раз ваше внимание, что при написании CSS очень важно использовать одинаковые разделители имени
элемента от имени блока для работы с ними из инструментов и JavaScript-функций.

Например, модификатором можно обозначить текущий пункт меню:

```xml
<b:menu>
  <e:item>Index<e:item>
  <e:item m:state="current">Products</e:item>
  <e:item>Contact<e:item>
</b:menu>
```

```js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'Index' },
    {
      elem: 'item',
      mods: { 'state' : 'current' },
      content: 'Products'
    },
    { elem: 'item', content: 'Contact' }
  ]
}
```

```css
.menu__item_state_current
{
  font-weight: bold;
}
```

Что может быть представлено в HTML так:

```html
<ul class="menu">
  <li class="menu__item">Index</li>
  <li class="menu__item menu__item_state_current">Products</li>
  <li class="menu__item">Contact</li>
</ul>
```

Или так, чтобы сделать классы меню независимыми от деталей реализации его раскладки:

```html
<div class="menu">
  <ul class="menu__layout">
    <li class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </li>
  </ul>
</div>
```

```html
<div class="menu">
  <table class="menu__layout">
  <tr>
    <td class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </td>
  </tr>
  </table>
</div>
```

### Предметная абстракция
Если над проектом работает много людей, им нужно договариваться о предметной области.
У всех блоков проекта должны быть однозначные имена, которые используются в коде.

Например, реализованный на сайте блок `Облако тегов` всегда называется `tags`, а каждый элемент
(метка) в нём - `tag`. Это справедливо для любой технологии: CSS, JS, XSL, etc.

С точки зрения процесса разработки:
 * Все участники процесса оперируют одними терминами

С точки зрения CSS:
 * CSS блоков и элементов можно описывать на псевдоязыке, который затем компилируется в чистый
   CSS согласно принятой схеме именования.

```css
.menu {
  __layout {
    display: inline;
  }
  __layout-item {
    display: inline-block;
    …
  }
  __item {
    _state_current {
      font-weight: bold;
    }
  }
}
```

С точки зрения JavaScript:
 * Не нужно обращаться к DOM-узлам блоков и элементов по имени класса:

```js
$('menu__item').click( … );
$('menu__item').addClass('menu__item_state_current');
$('menu').toggle('menu_size_big').toggle('menu_size_small');
```

Схема именования CSS-классов для блоков и элементов может измениться. При использовании специальных
JavaScript-функций для обращения к блокам и работы с их модификаторами нужно будет внести изменения
только в эти функции

```js
block('menu').elem('item').click( … );
block('menu').elem('item').setMod('state', 'current');
block('menu').toggleMod('size', 'big', 'small');
```

Приведённый здесь код - абстрактный. В реальных разработках мы используем JavaScript-ядро блока
`i-bem` из библиотеки bem-bl: <http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html>

### Консистентность блока
На нашем сайте реализован блок `Кнопка`, у которого есть динамическое поведение.

![Кнопка](http://img-fotki.yandex.ru/get/6728/221798411.0/0_babcb_d1c8832d_M.png)

При наведении курсора на этот блок он меняет свой внешний вид.

![Кнопка при наведении](http://img-fotki.yandex.ru/get/9110/221798411.0/0_babca_47ce403c_M.png)

Менеджер может попросить использовать такую же кнопку на другой странице.

Просто CSS-реализации блока недостаточно. Ведь в данном случае, чтобы полностью повторить блок,
нужно повторить и его поведение, описанное в JavaScript.

Таким образом, блок должен знать о себе всё. То есть реализация блока подразумевает описание его
внешнего вида и поведения во всех необходимых технологиях. Этот принцип мы называем `мультилингвальность`.

`Мультилингвальность` - это описание блока на всех языках (технологиях), необходимых для его работы.

Если блок нужно представить на странице, у него должны быть реализованы технологии:
 * шаблоны (XSL, TT2, JavaScript, и т.д.), превращающие декларацию блока на странице в HTML-код
 * CSS, отвечающий за внешний вид блока
 * JavaScript-реализация блока, если у блока также есть динамическое поведение
 * Картинки, относящиеся к блоку
 * Документация к блоку

В список технологий входит всё, что относится к блоку.

### Примеры из реальной жизни
Наиболее широко методологию БЭМ применяет в своих frontend разработках компания [Яндекс](http://company.yandex.ru).

БЭМ-методология не требует применения определённого фреймворка. Также не обязательно
применять методологию для всех web-технологий, используемых для построения страницы (хотя
это был бы наиболее эффективный путь).

[Все сервисы Яндекса](http://www.yandex.ru/all) применяют методологию БЭМ в своём
CSS и JavaScript коде и XSL шаблонах страниц. Например,
 * [Яндекс.Карты](http://maps.yandex.ru/?text=%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F%2C%20%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B0&sll=37.609218%2C55.753559&ll=37.609218%2C55.753563&spn=2.570801%2C0.884460&z=9&l=map)
 * [Яндекс.Картинки](http://images.yandex.ru/yandsearch?text=Yandex+office&rpt=image)
 * [Яндекс.Видео](http://video.yandex.ru/#search?text=yac%202011)
 * [Яндекс.Авто](http://auto.yandex.ru/)
 * [Яндекс в Турции](http://www.yandex.com.tr/)

Некоторые сервисы вместо XSL шаблонов используют упомянутые в статье `bemhtml` шаблоны:
 * [Поиск Яндекса](http://yandex.ru/yandsearch?text=BEM+methodology+front-end&lr=213)  
 * [Поиск на английском](http://yandex.com/yandsearch?text=%22What+is+BEM%3F%22+front-end&lr=213)
 * [Поиск по мобильным приложениям](http://apps.yandex.ru/)  
    Сайт для смартфонов

Другие российские порталы также используют БЭМ.

Например, сервисы [Mail.ru](http://mail.ru/) частично реализованы с применением БЭМ.
Это касается CSS реализации страниц, а также собственного C++ шаблонизатора компании.

Другие примеры:
 * [Рамблер.Новости](http://beta.news.rambler.ru/)
 * [HeadHunter](http://hh.ru/)
 * [TNK Racing Team](http://futurecolors.ru/tnkracing/)

Сайты, разработанные на основе [библиотеки bem-bl](http://bem.github.com/bem-bl/index.ru.html):
 * [Mikhail Troshev vCard](http://mishanga.pro/)  
    Код проекта на GitHub: <https://github.com/mishanga/bem-vcard>
