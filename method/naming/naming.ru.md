# Соглашение по именованию

Методология БЭМ оперирует понятиями БЭМ-сущностей: [блоков](../definitions/definitions.ru.md#bem-block), [элементов](../definitions/definitions.ru.md#bem-element) и [модификаторов](../definitions/definitions.ru.md#bem-mods). Прежде чем начать с ними работать, необходимо ознакомиться с правилами их именования.

Соглашение по именованию позволяет всегда одинаково называть БЭМ-сущности независимо от того, пишете ли вы CSS, JavaScript, шаблоны или работаете с файловой системой проекта. Благодаря общим принципам вы всегда понимаете из названия, о какой БЭМ-сущности идет речь.

Жесткие правила именования упрощают разработку и отладку кода. А также решают многие [насущные для веб-разработчика проблемы](problems.ru.md) только за счет соглашения по именованию CSS-селекторов.

## Соглашения по именованию CSS-селекторов

Основная идея соглашения — сделать имена CSS-селекторов более понятными и дать возможность разработчикам с их помощью различать блоки, элементы и модификаторы.

Рассмотрим простой CSS-селектор `menuitemvisible`. Такую запись сложно воспринимать особенно при быстром просмотре. Напрашивается добавление какого-нибудь разделителя.

Например:

`menu-item-visible` или `menuItemVisible`

В таком виде имя селектора становится намного понятнее за счет явного выделения логических частей: отдельные имена легко вычленить из общей записи. Достаточно легко предположить, что `menu` в данном случае, скорее всего, окажется блоком, `item` — элементом, а `visible` — модификатором. В таком простом примере все очевидно, однако жизненные ситуации зачастую намного сложнее и не столь однозначны.

  //Методология БЭМ использует жесткие правила именования CSS-селекторов, которые помогают не только легко воспринимать имена сущностей, но и точно определять их типы.

Приведенные в данном разделе примеры основаны на классическом стиле именования, описанном ниже. Однако БЭМ-методология не исключает наличия [альтернативных схем](#name-scheme).

## Классическая схема именования

* Имена БЭМ-сущностей записываются с помощью **латинских букв** в **нижнем регистре**.
* Для разделения слов в именах используется **дефис** (`-`).
* Для хранения информации об именах блоков, элементов и модификаторов используются **CSS-классы**.

> Почему мы используем CSS-классы и какие есть альтернативы читайте [тут](faq.ru.md).

### Имя блока

Имя блока формируется как `block-name` и служит [неймспейсом](https://ru.wikipedia.org/wiki/Пространство_имён) для элементов и модификаторов.

**Пример**

`lang-switcher`

`button`

Иногда к именам блоков могут добавляться различные префиксы. Подробнее о нашем опыте использования префиксов рассказывается в статье [История создания БЭМ](https://ru.bem.info/method/history/#Появление-блоков).

**HTML**

```html
<div class="block">...</div>
```

**CSS**

```css
.block { color: red; }
```

### Имя элемента

Для определения принадлежности элемента к блоку используется неймспейс в виде имени блока, который отделяется от имени элемента двумя подчеркиваниями (`__`).

Полное имя элемента создается по схеме:

`block-name__elem-name`

Если блок имеет несколько одинаковых элементов, как в случае пунктов меню, то все они будут иметь одинаковые имена.

**Пример**

`lang-switcher__item`

`menu__group-title`

**HTML**

```html
<div class="block">
  ...
  <span class="block__elem"></span>
</div>
```

**CSS**

```css
.block__elem { color: red; }
```
_________________________________________

**Важно!** В методологии БЭМ не существует элементов элементов.

Неймспейсом служит только имя блока. Отражать вложенность в именах элементов не имеет смысла, так как это не позволит легко вынуть один элемент из другого при повторном использовании блока в другой ситуации (или при рефакторинге).

>Неверно

>```css
.nav__item__link {}
>```

Для выражения семантической связи достаточно указать более точное имя элемента.

```css
.nav__item-link {}
```

### Имя модификатора

Для определения принадлежности модификатора к блоку или элементу используется неймспейс в виде имени блока или имени элемента, который отделяется от имени модификатора одним подчеркиванием (`_`).

Полное имя модификатора создается по схеме:

* Для булевых модификаторов<br>
    `owner-name_mod-name`

* Для модификаторов вида «ключ-значение»<br>
    `owner-name_mod-name_mod-val`

#### Модификатор блока

* **Булевый модификатор**. Значение такого модификатора не указывается. Полное имя создается по схеме: `block-name_mod-name`.<br>
**Пример**

    `menu_visible`

* **Модификатор типа «ключ — значение»**. Значение модификатора отделяется от имени одним подчеркиванием (`_`). Полное имя создается по схеме: `block-name_mod-name_mod-val`.<br>
**Пример**

    `menu_type_radio`

**HTML**

```html
<div class="block block_hidden">...</div>
<div class="block block_theme_forest block_size_large">...</div>
```

**CSS**

```css
.block_hidden { display: none }
.block_theme_forest { color: green; }
```

>**Неправильное использование**<br>
В данном случае модификатор указан без самого блока, на который он влияет. В БЭМ-методологии модификатор не может использоваться в отрыве от своего владельца.

>```html
<div class="block_hidden">...</div>
>```

#### Модификатор элемента

* **Булевый модификатор**. Значение такого модификатора не указывается. Полное имя создается по схеме: `block-name__elem-name_mod-name`.<br>
**Пример**

    `menu__item_visible`

* **Модификатор типа «ключ — значение»**. Значение модификатора отделяется от имени одним подчеркиванием (`_`). Полное имя создается по схеме: `block-name__elem-name_mod-name_mod-val`.<br>
**Пример**

    `table__box_align_top-left`

**HTML**

```html
<div class="block">
  ...
  <span class="block__elem block__elem_theme_green"></span>
</div>
```

**CSS**

```css
.block__element_theme_green { color: green; }
```

### Пример

**HTML**

```html
<form class="form form_theme_greem form_login">
  <input class="form__input">
  <input class="form__submit form__submit_disabled">
</form>
```

**CSS**

```css
.form {}
.form_theme_green {}
.form_login {}
.form__input {}
.form__submit {}
.form__submit_disabled {}
```

<a name="name-scheme"></a>
## Альтернативные схемы именования по БЭМ-методологии

Существуют альтернативные решения использования БЭМ-методологии.

**Стиль Гарри Робертса**

Одним из первых, кто заговорил о БЭМ в англоязычном мире был [Гарри Робертс](http://csswizardry.com/work/). В своей статье [MindBEMding&nbsp;–&nbsp;getting your head ’round BEM syntax](http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/) он рассказал о соглашении по именованию CSS-классов по БЭМ-методологии. Гарри Робертс предложил свою схему именования, основанную на принципах БЭМ:

`block-name__elem-name--mod-name`

* Имена записываются в нижнем регистре.
* Для разделения слов в именах БЭМ-сущностей используется дефис (`-`).
* Имя элемента отделяется от имени блока с помощью двух подчеркиваний (`__`).
* Булевые модификаторы отделяются с помощью двух дефисов (`--`).
* Модификаторы вида «ключ-значение» не используются.

**Стиль без подчеркиваний**

`blockName-elemName--modName--modVal`

* Имена записываются с помощью [верблюжего регистра](https://ru.wikipedia.org/wiki/CamelCase).
* Имя элемента отделяется от имени блока с помощью одного дефиса (`-`).
* Для отделения модификатора используется два дефиса (`--`).
* Значение модификатора отделяется от его имени с помощью двух дефисов (`--`).

**Стиль CamelCase**

 MyBlock__SomeElem_modName_modVal

Данный стиль отличается от классического использованием «верблюжего регистра» вместо дефиса для разделения слов в именах БЭМ-сущностей.

**Стиль no-namespace**

`_available`

Основное отличие данного стиля в отсутствии имени блока перед модификатором. При такой форме записи придется отказаться от [миксов](definitions#bem-mixes), так как нет возможности отличить, к какому блоку относится модификатор.

> **Какой стиль выбрать?**

>Методология БЭМ предлагает идею решения существующих проблем и свой способ реализации этой идеи. Но выбор всегда остается за разработчиком: использовать классический стиль, один из альтернативных или придумать свою схему именования.

>Использование классического стиля имеет один существенный плюс — все предлагаемые инструменты [платформы БЭМ]() ориентируются именно на классическое именование.

>Инструмент [bem-naming](https://ru.bem.info/tools/bem/bem-naming/#%D0%91%D0%AD%D0%9C-%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F), который предоставляет информацию о БЭМ-сущности по строке и формирует ее строковое представление на основе БЭМ-нотации, содержит по умолчанию настройки для классического стиля, но позволяет добавлять альтернативные правила для использования новых схем именования.
