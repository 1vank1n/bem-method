# Соглашение по именованию

Методология БЭМ оперирует понятиями БЭМ-сущностей: [блоков](../definitions/definitions.ru.md#bem-block), [элементов](../definitions/definitions.ru.md#bem-element) и [модификаторов](../definitions/definitions.ru.md#bem-mods). Прежде чем начать с ними работать, необходимо ознакомиться с правилами их именования.

Соглашение по именованию позволяет всегда одинаково называть БЭМ-сущности независимо от того, пишете ли вы CSS, JavaScript, шаблоны или работаете с файловой системой проекта. Благодаря общим принципам вы всегда понимаете из названия, о какой БЭМ-сущности идет речь.

Жесткие правила именования позволяют в разы увеличить скорость разработки и отладки кода. А также решить многие [насущные для веб-разработчика проблемы](problems.ru.md) только за счет соглашения по именованию CSS-селекторов.

## Соглашения по именованию CSS-селекторов

Основная идея соглашения — сделать имена CSS-селекторов более понятными и дать возможность разработчикам с их помощью различать блоки, элементы и модификаторы.

Рассмотрим простой CSS-селектор `menuitemvisible`. Такую запись сложно воспринимать особенно при быстром просмотре. Напрашивается добавление какого-нибудь разделителя. Например:

`menu-item-visible` или `menuItemVisible`

В таком виде имя селектора становится намного понятнее за счет явного выделения логических частей: отдельные имена легко вычленить из общей записи. Достаточно легко предположить, что `menu` в данном случае, скорее всего, окажется блоком, `item` — элементом, а `visible` — модификатором. В таком простом примере все очевидно, однако жизненные ситуации зачастую намного сложнее и не столь однозначны.

Методология БЭМ использует жесткие правила именования CSS-селекторов, которые помогают не только легко воспринимать имена сущностей, но и точно определять их типы.

Приведенные в данном разделе примеры основаны на классическом стиле именования, описанном ниже. Однако он не исключает наличия [альтернативных схем](#name-scheme).

### Общие положения

* Все имена БЭМ-сущностей записываются с помощью латинских цифр и букв в **нижнем регистре**.
* Для разделения слов в именах используется **дефис** (`-`).
* Для хранения информации о блоках, элементах и модификаторах используются **CSS-классы**.

> Почему мы используем CSS-классы и какие есть альтернативы читайте [тут](faq.ru.md).

### Имя блока

Имя блока формируется как `block`.

Оно служит [неймспейсом](https://ru.wikipedia.org/wiki/Пространство_имён) для элементов и модификаторов блока.

**Примеры**

`lang-switcher`

`button`

**HTML**

```html
<div class="block">...</div>
```

**CSS**

```css
.block { color: red; }
```

>#### Использование префиксов в именах блоков

>Иногда для большей информативности в имена блоков могут добавляться различные префиксы.

>Так, [исторически сложившейся традицией](https://ru.bem.info/method/history/#Префиксы) в БЭМ было использование префикса `b-` (от `block`) для обозначения блока с визуальным представлением. А префиксы `i-` или `js-` (от `include` и `javascript`) означали, что блок не имеет визуальной реализации и является вспомогательным для построения других блоков. Но так как сейчас большая часть блоков имеет JS-представление, то уже нет необходимости отличать технологии реализации блока на уровне имен.

>**Пример**

>`b-link`

### Имя элемента

Имя элемента формируется как `element`.

Для определения принадлежности элемента к блоку используется неймспейс в виде имени блока, который отделяется от имени элемента двумя подчеркиваниями (`__`).

Полное имя элемента создается по схеме:

`block__element`

Если блок имеет несколько одинаковых элементов, как в случае пунктов меню, то все они будут иметь одинаковые имена.

**Пример**

`lang-switcher__item`

`menu__group-title`

**HTML**

```html
<div class="block">
  ...
  <span class="block__elem"></span>
</div>
```

**CSS**

```css
.block__elem { color: red; }
```

>Неправильное использование CSS-правил

```css
.block .block__elem { color: red; }
div.block__elem { color: red; }
```
_________________________________________

**Важно!** В методологии БЭМ не существует элементов элементов.

Неймспейсом служит только имя блока. Отражать вложенность в именах элементов не имеет смысла, так как это не позволит легко вынуть один элемент из другого при повторном использовании блока в другой ситуации (или при рефакторинге).

>Неверно

```css
.nav__item__link {}
```

**Note** Для выражения подобной связи можно указать более точное имя элемента.

>Верно

```css
.nav__item-link {}`
```

Для выражения вложенности вполне достаточно DOM-дерева:

```html
<ul class="nav">
    <li class="nav__item">
        <a class="nav__link"></a>
    </li>
</ul>
```

### Имя модификатора

Имя модификатора формируется как `modifier_value`.

Модификаторы одтеляются от имени блока или имени элемента нижним подчеркиванием (`_`).

Виды модификаторов:

* **Булевый модификатор**. Значение такого модификатора не указывается.
Например, `_visible`.

* **Модификатор типа «ключ — значение»**. Значение отделяется от имени одним подчеркиванием (`_`). Например, `_size_large`, `_type_search`.

Полное имя модификатора создается по схеме:

* Для булевых модификаторов<br>
    `owner_modifier`
* Для модификаторов вида «ключ-значение»<br>
    `owner_modifier_value`

#### Модификатор блока

Булевый: `модификатор`.

Вид «ключ – значение»: `block_modifier_value`.

**Пример**

`lang-switcher_disabled`

`menu_type_radio`

**HTML**

>Правильное использование

```html
<div class="block block_mod">...</div>
<div class="block block_theme_green block_size_large">...</div>
```
>Неправильное использование

```html
<div class="block_mod">...</div>
```

**CSS**

```css
.block_mod { display: none }
.block_theme_green { color: green; }
```

#### Модификатор элемента

Булевый: `block__element_modifier`.

Вид «ключ – значение»: `block__element_modifier_value`.

**Пример**

`lang-switcher__item_visible`

`table__box_align_top-left`

**HTML**

```html
<div class="block">
  ...
  <span class="block__elem_theme_green"></span>
</div>
```

**CSS**

```css
.block__element_theme_green { color: green; }
```

### Пример применения соглашения по именованию БЭМ

**HTML**

```html
<form class="form form_theme_greem form_login">
  <input class="form__input">
  <input
    class="form__submit form__submit_disabled">
</form>
```

**CSS**

```css
.form {}
.form_theme_green {}
.form_login {}
.form__input {}
.form__submit {}
.form__submit_disabled {}
```

<a name="name-scheme"></a>
## Альтернативные схемы именования по БЭМ-методологии

Существуют альернативные решения использования БЭМ-методологии.

**Стиль Гарри Робертса**

Одним из первых, кто заговорил о БЭМ в англоязычном мире был [Гарри Робертс](http://csswizardry.com/work/). В своей статье [MindBEMding – getting your head ’round BEM syntax](http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/) он рассказал о соглашении по именованию CSS-классов по БЭМ-методологии. Гарри Робертс предложил свою схему именования, основанную на принципах БЭМ:

`block-name__elem-name--mod-name`

* Имена записываются в нижнем регистре.
* Для разделения слов в именах БЭМ-сущностей используется дефис (`-`).
* Имя элемента отделяется от имени блока с помощью двух подчеркиваний (`__`).
* Булевые модификаторы отделяются с помощью двух дефисов (`--`).
* Модификаторы вида «ключ-значение» не используются.

**Стиль без подчеркиваний**

`blockName-elemName--modName-modVal`

* Имена записываются с помощью «верблюжего регистра».
* Имя элемента отделяется от имени блока с помощью одного дефиса (`-`).
* Для отделения модификатора используется два дефиса (`--`).
* Значение модификатора отделяется от его имени с помощью одного дефиса (`-`).

**Стиль с использованием модификатора без имени блока**

`__available`

Основное отличие данного стиля в отсутствии имени блока перед модификатором. При такой форме записи придется отказаться от [миксов](), так как нет возмоности отличить к какому блоку относится модификатор.

**Стиль, основанный на «верблюжем регистре»**

`BlockElementModifier`

Имена сущностей разделяются при помощи «верблюжего регистра».

> **Какой стиль выбрать?**

>Методология БЭМ предлагает идею решения существующих проблем и свой способ реализации этой идеи. Но выбор всегда остается за разработчиком: использовать классический стиль, один из альтернативных или придумать свою схему именования.

>Использование классического стиля имеет один существенный плюс – все предлагаемые инструменты [платформы БЭМ](), в том числе и с открытыми исходниками, ориентируются именно на классическое именование.

>Инструмент [bem-naming](https://ru.bem.info/tools/bem/bem-naming/#%D0%91%D0%AD%D0%9C-%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F), который предоставляет информацию о БЭМ-сущности по строке и формирует ее строковое представление на основе БЭМ-нотации, содержит по умолчанию настройки для классического стиля, но позволяет добавлять альтернативные правила для использования новых схем именования.
