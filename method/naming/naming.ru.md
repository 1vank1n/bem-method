БЭМ-методология – это набор правил и принципов организации фронтенд-разработки. Самым широко известным и массово используемым принципом БЭМ является **соглашение по именованию сущностей**.

Одним из первых за пределами нашей компании об использовании принципа именования сущностей по БЭМ заговорил Гарри Робертс. Он показал преимущества такого подхода применимо к CSS. Вот почему многие его последовали так и продолжают считать БЭМ методологией именования CSS-классов. Но это не так: правила именования в БЭМ относятся не только к CSS, а БЭМ-методология объединяет в себе намного больше принципов, помогающих граммотно построить разработку и поддержку вашего проекта. (Мы не отрицаем, что с CSS-классами в БЭМ связано много чего, как раз об этом рассказано в этой статье) Однако, с CSS-классами в БЭМ много чего связано, но подробно об этом дальше.

Разрабатывая любой проект все команды в какой-то момент сталкиваются с проблемой, когда большая часть кода поддерживается одним человеком, потому что только он понимает, как всё работает. Погружение в материал другого разработчика требует колоссальных временных затрат. Такая ситуация приводит к сложностям при перемещении людей между проектами, расширении команды и банально нехваткой времени человека, обладающего сакральными знаниями. Сроки затягиваются, а команда превращается в неповоротливого, непослушного слона, в то время как заказчикам чаще всего хочется совершенно другого. (быть кукловодами, которые лишь дернув одну веревочку, запускают весь механизм.)

Методология БЭМ помогает наладить взаимодействие в команде проекта, предоставив всем ее членам **общий язык для общения** на всех уровнях разработки от составления дизайна до управления проектом, возможность осмысленного **использования кода без погружения в детали** и способность любого разработчика ориентироваться в разных частях проекта благодаря **самодокументируемости кода**.

* Семантика – основа веб-разработки
* Переход от структуры к БЭМ-сущностям (BEM tree)
* Разбиение на логические части и независимость блоков
  * Блок
  * Элемент
  * Модификатор
* Соглашения по именованию
  * Имя блока
  * Имя элемента
  * Имя модификатора
* Namespace и поддержка длинных имен классов
* Миксы
  //* Один блок на разных DOM-узлах
* БЭМ и самодокументируемый код
* От правил именования — к Style Guide

## Семантика – основа веб-разработки

На сегодняшний день одним из важнейших критериев профессиональной веб-разработки является семантичность кода. Разработчик вынужден управляться и совмещать различные технологии, которые используют разные семантические модели: CSS как технология вообще не предлагает какой-либо структуры, высокоуровневые JavaScript-реализации работают с дополнительным уровнем абстракции, который чаще всего слабо связан с CSS- или HTML-разметкой, дизайнерские макеты вообще описываются терминами, далекими от технической реализации. Все говорят об одном и том же на разных языках.

Методология БЭМ способна связать воедино все эти предметные области, так как представляет собой общую семантическую модель для разметки, стилей и кода.

Новые стандарты, такие как Web Components, также пытаются вернуть семантику в жизнь веб-разработчиков, но они в отличие от БЭМ зависят от конкретного API и поддержки браузеров. Методологию БЭМ можно внедрять уже сегодня, сохраняя потенциал для интеграции с новыми современными технологиями, так как сама идея не зависит ни от конкретного API, ни от конкретной технологии.

## Переход от структуры к БЭМ-сущностям (BEM tree)

Но как начать использовать БЭМ, если браузеры по-прежнему понимают только HTML и разработчик всё ещё вынужден с ним работать? Проблему может решить соглашение об именовании, которое свяжет DOM-узлы с БЭМ-сущностями.


Для задания этой связи БЭМ использует **CSS-классы** – БЭМ превращает CSS из простого языка описания стилей в инструмент, описывающий семантику любого проекта.

CSS-классы используются для хранения информации о блоках, элементах и модификаторах и формируются из имен БЭМ-сущностей (подробная информация в разделе [Соглашения по именованию](#)). Таким образом БЭМ перестает ориентироваться на структуру страницы и позволяет создать семантический слой поверх существующей DOM-реализации.

Технология, реализующая такой уровень абстракции над DOM, называется БЭМ-деревом. БЭМ-дерево лежит в основе методологии и позволяет работать с БЭМ-сущностями в БЭМ-терминах. БЭМ-дерево представляет собой объектную модель, которая поддерживает вложенность использования блоков, элементов и модификаторов и их значений.

Блоки, элементы и модификаторы не размещаются на DOM-узлах эксклюзивно; на одном теге может быть определено сразу несколько блоков, либо же элемент блока может быть объединен с контейнером другого блока. Использование одного и того же DOM-узла для размещения нескольких сущностей называется [микс](#). В достаточно редких случаях один блок может также использоваться на разных DOM-узлах.

## Разбиение на логические части и независимость блоков

Возмоность мыслить и работать на уровне сущностей и не слишком зависеть при этом от структуры страницы позволила разбить содержимое на логические блоки и сделать их независимыми друг от друга.

Основная идея схожа с принципами ООП — иметь возможность создать ограниченное число повторно используемых компонентов, которые могут содержать целый диапазон разных типов контента. Такой подход позволяет создавать более надежные, гибкие и пригодные для повторного использования компоненты.

Разделение на блоки (модульный подход) позволяет легче распараллеливать разработку, и защищает от ситуации «единоличного контроля» разработчика над важной частью проекта, поскольку сам БЭМ-подход поощряет модульность. Кроме этого, в любом самом сложном коде базовые приёмы работы с данными (БЭМ-дерево, модификаторы, взаимодействие блоков) будут одинаковыми; разбираться в таком коде проще, поддерживать его — легче.

### Блок

Блок – это независимый компонент страницы, который содержит всю информацию о себе и своих элементах.
Блок – это ключевая сущность БЭМ-методлологии.

Блок – это тот логический фрагмент страницы, который разработчик собирается использовать в будущем. Блоки можно свободно перемещать по странице, между разными страницами или разными проектами, они не зависят от структуры самой страницы. Блок имеет публичный API для взаимодействия с другими блоками, но детали внутренней реализации блока срыты от пользователей.

Блок в БЭМ может содержать набор обязательных и необязательных элементов или не иметь их вообще. При этом блоком может быть как совершенно простым, например, `кнопка`, так и достаточно сложным, содержащим в себе другие блоки и дополнительные элементы, например, `шапка`.

// пример с картинкой сначала для кнопки, пототм для шапки

Один из главных критериев независимости блока – его уникальное имя, чаще всего указывающее на его назначение.

### Элемент


Элемент – это часть блока, отвечающая за определенную функцию.
Элементы не могут существовать и использоваться в отрыве от блока, к которому они относятся.

Все элементы блока полностью инкапсулированы, то есть доступны только внутри этого блока. В то время как Web Components используют ShadowDOM для инкапсуляции дерева элементов, БЭМ решает эту же задачу за счет использования пространства имен ([namespace](#)). Реализация БЭМ не требует поддержки браузеров. Инкапсуляция блоков в БЭМ дает возможность использовать код без знания деталей, когда разные компоненты не влияют на внутренний мир друг друга.

Примерами элементов блока могут служить пункты меню, строки и ячейки таблицы.

При объявлении блока на странице разработчику не нужно описывать все элементы. Обязательные элементы подключаются на сраницу автоматически. Проще всего объяснить это на примере:

//пример с блоком меню и его элементами – пунктами меню ?? у нас это блоки

Элементы определяются по смыслу, а не исходя из HTML-верстки блока; так, отдельный элемент может быть представлен сложной HTML-структурой.

//пример

### Модификатор

Модификатор — это свойство блока или элемента, определяющее их внешний вид, состояние или поведение. Модификаторы относятся или к блоку, или к элементу конкретного блока. Ситуация, когда один модификатор относится и к блоку, и к его элементу невозможна.

Модификаторы бывают булевыми (например, `visible : true` или `false`) или представляют собой пару «ключ — значение» (`size : large`, `medium`, `small`). Это чем-то похоже на атрибуты в HTML, но всё-таки не то же самое. У сущности может быть несколько модификаторов, если эти модификаторы описывают разные вещи.

Например, обычное поле ввода `input` может быть изменено на поле для ввода пароля с помощью модификатора `input_type_button`, но оно также может быть неактивным (модификатор `disabled`). Тогда в  HTML это будет выглядеть так:

```html
<span class="input input_type_password input_disabled"></span>
```

## Соглашения по именованию

Методология БЭМ предоставляет набор рекомендаций и правил по именования сущностей. Командой БЭМ разработана [схема именования](#ссылка на платформенную часть, где описывается парвила нашей схемы про нижние подчеркивания и тире), основанная на всех правилах методологии и примеры в данном разделе будут приводиться с учетом этой схемы.

Приведенная здесь система именования классов по БЭМ не единственная. Существуют и другие варианты, предложенные упомянутым выше [Гари Робертсом](#), [Николасом Галахером](#) и другими сторонниками БЭМ. Все самые известные существующие схемы описаны в разделе [схемы именования](#).

### Имя блока

Имя блока является ключевым словом или связкой слов, определяющей назначение блока. Все зависимые от блока сущности будут опираться на это имя в своих названиях. Таким образом у разработчика появляется возможность на самом верхнем уровне прослеживать взаимосвязь между блоками, элементами и модификаторами.

Например, блоками могут быть заголовок, кнопка или навигационное меню. Соответственно, и названия у них будут скорее всего `header`, `button` и `menu`. Согласитесь, не сложно разобраться, какое название соответствует тому или иному блоку.

Полное имя блока может выглядеть следующим образом: `имя-блока` или `префикс-имя-блока`.

Иногда для большей информативности и простоты восприятия/чтения кода в имена блоков могут добавляться различные префиксы. Так, исторически сложившейся традицией было использование префикса `b-` (от `block`) для обозначения блока с визуальным представлением. А префикс `i-` (от `include`) означал, что блок скорее всего не имеет визуальной реализации и является вспомогательным для построения других блоков.

Сейчас префиксы используются гораздо реже и только в вынужденных случаях, как например в именовании классов CSS для реализации пространства имен.

Пример

`button`

`checkbox-group`

`b-link`

### Имя элемента

Полное имя элемента формируется так, чтобы из него можно было определить принадлежность данного элемента к конкретному блоку.

Полное имя элемента создается по схеме:

`имя-блока__имя-элмента`

Элементами могут быть пункты с списке меню или строки, ячейки и заголовки в таблице. Если внутри блока несколько одинаковых элементов, как в случае пунктов меню, то они идут под одним именем.

Пример

`menu__menu-item`

`table__box`

### Имя модификатора

Полное имя модификатора блока формируется так, чтобы из него можно было определить принадлежность данного модификатора к его «владельцу», и использует следующую схему: имя владельца, одно подчеркивание, имя модификатора.

`имя-блока_имя-модификатора`
`имя-блока__имя-элемента_имя-модификатора`

Пример

`menu_focused`
`table__box_disabled`

Для булевых модификаторов такой формы записи будет достаточно. Если модификатор — пара «ключ-значение», то значение модификатора отделяется еще одним подчеркиванием:

`имя-блока_имя-модификатора_значение-модификатора`
`имя-блока__имя-элемента_имя-модификатора_значение-модификатора`

Пример

`menu_layout_horiz`
`table__box_align_left`

## Namespace и поддержка длинных имен

Первый раз увидев и не испробовав на практике описанные выше правила именования, многие разработчики пугаются длинных имен классов и непривычного вида кода. Самое распространенное негодование со стороны разработчиков вызывают именно длинные именя классов.

БЭМ-методология предполагает использовать максимально понятные названия блоков, но ни в коем случае не запрещает писать классы типа `btn` вместо `button`. Точно такая же ситуация и с названием переменных в JavaScript: `context`, `ctx` или `c`. Но за стремлением сократить количество букв основная идея не должна потеряться: код должен быть максимально понятен не только тому, кто его написал, но и разработчику, пришедшему на проект.

Использование пространства имен (namespace) не позволяет как-либо сократить имена классов: имя блока всегда пишется перед именем элементов (`button__icon`) и модификаторов (`button_active`). И как результат любой разработчик может увидеть 2 потенциальных минуса:

* Результирующий код весит больше. Однако, с помощью `gzip`, который отлично сжимает повторяющиеся последовательности, этот минус не имеет никакого значения.
* Длинные названия все равно дольше писать, чем короткие. С этим утверждением сложно не согласиться, но можно использовать автокомплит в редакторе или инструменты, которые атвоматически добавляют префиксы (CSS-препроцессоры и шаблонизаторы).

Зато плюсов можно разглядеть намного больше:

* Прозрачная архитектура проекта.
* Лекго читаемый код. Зависимости мжду блоками, элементами и модификаторами всегда понятны.
* Независимый код блока во всех технологиях, который благодаря использованию пространств имен сложно «случайно» изменить, работая с другими компонентами страницы. Аналог реализации Shadow DOM, который решается простым добавлением имени блока.

## Миксы

Под миксом подразумевается смешивание на одном DOM-узле разных блоков и элементов. Это дает возможность переиспользовать уже имеющиеся части кода и совместить их поведение и стили без дополнительных усилий.

На одном DOM-узле может быть:

* несколько блоков
  b-menu b-head-menu
* блок и элемент этого же блока
  b-menu b-menu__layout
* блок и элемент другого блока
  b-link b-menu__link
* элемент одного блока и элемент другого блока
  b-menu__item b-head-menu__item
* блок с модификатором и другой блок
  b-menu b-menu_layout_horiz b-head-menu
* блок с модификатором и другой блок с модификатором
  b-menu b-menu_layout_horiz b-head-toolbar b-head-toolbar_theme_black

Пример

Переключатель панелей имеет элементами табы (b-tabbed-pane__tabs) и панели (b-tabbed-pane__panels). Эти два элемента находятся на одном DOM-узле одновременно, что позволяет легко менять расположение элементов на странице с вертикального на горизонтальное.


## БЭМ и самодокументируемый код

Как чаще всего происходит разработка проекта? Разработчик, ответственный за свою часть «пилит» доверенную ему функциональность, при этом имея только общее представление о всем продукте вцелом и совершенно не вникая в детали реализации параллеьных процессов. Казалось бы, это и не нужно знать, да и вникнуть во все нюансы проекта просто невозможно. В этом нет необходимости ровно до того момента, когда не случается передача проектов между командами, перераспределние задач между разработчиками, или увеличение команды хотя бы на одного человека.

Большинство разработчиков сталковались с переходом на новый проект, который до нас уже какое-то время жил своей жизнью и успел накопить тысячи строк кода, но, как чаще всего бывает, не успел обзавестись подробной документацией. Даже когда вы переходите на образцовый проект, документация к которому написана добросовестными разработчиками и поддерживается в актуальном состоянии, её часто не хватает – она описывает методы, свойства или API модулей, но редко касается «цикла работы» компонента, его возможных состояний и переходов между ними. Причина проста: это высокоуровневая семантика, и если не применять никакой методологии, то сам по себе код не даёт инструментов для её описания, поэтому и документация к коду часто не помогает: все методы описаны досконально, а как что работает — зачастую неясно.

В поддержке кода важно минимизировать время, которое разработчик тратит на то, чтоб понять, как всё устроено, где что лежит и как вообще это работает. Порой именно на это уходит львиная доля времени, а вовсе не на реализацию функциональности или исправление ошибки.

Одна из целей БЭМ — рассказать другим разработчикам как можно больше о том, что делает кусок кода, только по названиям классов в разметке. Читая HTML с небольшим количеством классов внутри, вы можете увидеть взаимодействия во всем коде и между его частями; что-то может быть независмым блоком, что-то дочерним элементом — элементом этого блока, а что-то может быть измененной копией — модификатором блока или элемента.

Используя соглашения об именовании сущностей разработчик сразу сможет понять следующее:

* о каком блоке идет речь;
* какие элементы включает в себя блок;
* какие модификаторы влияют на его состояние, поведение и внешний вид;
* с какими внешними блоками взаимодействуют компоненты;

Давайте рассмотрим пример с формой поиска на сайте:

```html
<form class="site-search  full">
    <input type="text" class="field">
    <input type="Submit" value ="Search" class="button">
</form>
```
Это обычные классы, по ним много не скажешь. Многие разработчики привыкли так с ними работать, но с БЭМ можно получить следующее:

```html
<form class="site-search  site-search_full">
    <input type="text" class="site-search__field">
    <input type="Submit" value ="Search" class="site-search__button">
</form>
```

Только из имен CSS-классов видно, что есть блок, названный `site-search`, у которого есть вложенный элемент `site-search__field`. Также наглядно видно, что существует модификации блока `site-search`, имеющая свой собственный класс `site-search_full`.

Жесткие правила именования в БЭМ позволяют сделать код вашего проекта более прозрачным, однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков и идеально подходит для крупных проектов и больших команд. Не прилагая дополнительных усилий вы получаете самодокументируемый код.

## От правил именования — к Style Guide

Теперь, когда разработчики вашего проекта понимают друг друга, работать над общим делом стало проще и быстрее. А сейчас представьте, если еще и дизайнеры, и руководители проектов начнут мыслить теми же категориями и говорить «на одном языке» с разработчиками. Звучит не совсем реально, но это возможно воплотить в жизнь, остается лишь предложить дизайнерам создавать свой стайлгайд в виде библиотеки интерфейчных блоков, описанных в терминологии БЭМ.

Такой подход облегчит жизнь не только разработчикам, но и самим дизайнерам, так как позволит перейти от дизайна «экранов» к работе с конкретными блоками и элементами. А это повлечет за собой следующие плюсы:

* сформируются основные «кирпичики» для построения сайта или приложения;
* отчетливее проявятся похожие компоненты различных частей интерфейса, которые скорее всего превратятся в отдельные блоки или их элементы. Это упростит работу разработчикам и позволит более точно оценивать время, необходимое на реализацию того или иного блока. Согласиьесь, гораздо проще работать над четко выделенными компонентами, чем с неделимым экраном-макетом, полученным от дизайнера.
* определяться визуальные вариации и состояния одного и того же компонента и станут называться модификаторами;
* произойдет переход к прототипированию с помощью схем и скетчей, так как если блоки имеют имя и зафиксированное в стайлгайде поведение, состояние и внешний вид, отрисовывать их в стиле «pixel perfect» во многих случаях станет вовсе необязательно;
* реализация модели дизайнера будет напрямую сопоставима с организацией кода разработчика;
* исчезнет пропасть между кодом и дизайном: дизайнер будет оперировать той же терминологией, что и разработчик, при этом ему не нужно будет учится программированию, а разработчику разбираться в терминах фотошопа.

Если проект разрабатывается на БЭМ то, скорее всего, многие блоки будут реализованы и останется только подключить их на страницу или немного расширить.



## Схемы именования

block-name__elem-name_mod-name_mod-val
 — классический вариант
block-name__elem-name--mod-name
 — Harry
blockName-elemName--modName-modVal
 — без подчёркиваний
