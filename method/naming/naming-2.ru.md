# Соглашение по именованию

БЭМ-методология оперирует понятиями [блоков](), [элементов]() и [модификаторов](). И прежде чем начать с ними работать, необходимо ознакомиться с правилами их именования.

Соглашение по именованию позволяет всегда одинаково называть БЭМ-сущности независимо от того, пишете ли вы CSS, JavaScript или шаблоны, или работаете с файловой системой проекта. Благодаря общей системе вы всегда понимаете из названия, о какой БЭМ-сущности идет речь.

БЭМ-методология задает ряд соглашений и правил по именованию CSS-селекторов(), соблюдение которых решает многие насущные для CSS- верстальщика и веб-разработчика проблемы:

* [Как уменьшить сложность кода?](#bem-simple-code)
* [Как начать переиспользоваь код?](#bem-reuse-code)
* [Как избежать взаимного влияния компонентов друг на друга и упростить рефакторинг?](#bem-split-code)
* [Как понять, о какой конкретно сущности идет речь? Определение всех частей сущности в отрыве от контекста.](#bem-clarify-code)
* [Как улучшить скорость рендеринга?](#bem-fast)

В этой статье мы расскажем, как простые правила именования БЭМ-сущностей решают все вышеперечисленные проблемы и делают ваш код понятным не только вам, но и другим разработчикам.

### Соглашения об именовании CSS-селекторов

Основная идея соглашения об именовании CSS-селекторов — сделать их более понятными и научиться различать блоки, элементы и модификаторы только по их именам.

Рассмотрим простой CSS-селектор `menuitemvisible`. Такую запись сложно воспринимать особенно при быстром просмотре. Напрашивается добавление какого-нибудь разделителя, например, `menu-item-visible` или `menuItemVisible`. В таком виде имя селектора становится намного понятнее за счет явного выделения логических частей: отдельные имена легко вычленить из общей записи и достаточно легко предположить, что `menu` в данном случае, скорее всего, окажется блоком, `item` — элементом, а `visible` — модификатором. В таком простом примере все очевидно, однако жизненные ситуации зачастую намного сложнее и не столь однозначны.

Методология БЭМ использует жесткие правила именования CSS-селекторов, которые помогают не только легко отделять имена сущностей друг от друга, но и со стопроцентной точностью определять тип БЭМ-сущности только по ее имени.

БЭМ использует CSS-классы для хранения информации о блоках, элементах и модификаторах.

<!-- Канонический стиль соглашения об именовании CSS-селекторов, предложенный методологией БЭМ, позволяет со стопроцентной точностью определить тип БЭМ-сущности по ее имени.
 -->
 Приведенные в данном разделе правила и примеры основаны на каноническом стиле именования, описанном ниже. Однако он не исключает наличия [альтернативных схем](#name-scheme), более подходящих вам или вашему проекту.

#### Имя блока

Имя блока формируется как `имя-блока-из-нескольких-слов`.

Имя блока служит [неймспейсом](https://ru.wikipedia.org/wiki/Пространство_имён) для его элементов и модификаторов.

**Примеры**

`lang-switcher`

`button`

`menu`

> ОФОРМИТЬ КАК ВРЕЗКУ
>##### Использование префиксов в именах блоков

>Иногда для большей информативности и простоты восприятия кода в имена блоков могут добавляться различные префиксы.

>Так, исторически сложившейся традицией в БЭМ было использование префикса `b-` (от `block`) для обозначения блока с визуальным представлением. А префикс `i-` или `js-` (от `include` и `javascript`) означал, что блок не имеет визуальной реализации и является вспомогательным для построения других блоков. Но так как сейчас большая часть блоков имеет JS-представление, то уже нет необходимости отличать технологии реализации блока на уровне имен.

>**Пример**

>`b-link`

#### Имя элемента

Имя элемента формируется также, как и имя блока `имя-элемента-из-нескольких-слов`.

Для определения принадлежности элемента к блоку, мы добавляем неймспейс в виде имени блока и отделяем его двумя подчеркиваниями. Полное имя элемента создается по схеме:

`имя-блока__имя-элмента`

**Пример**

`lang-switcher__item`

`menu__item`

`table__row`

Если блок имеет несколько одинаковых элементов, как в случае пунктов меню, то все они будут иметь одинаковое имя.

_________________________________________

**Важно помнить!** В методологии БЭМ не существует элементов элементов.

Неймспейсом служит только имя блока. Отражать вложенность в именах элементов не имеет смысла, так как это не позволит легко вынуть один элемент из другого при повторном использовании блока в другой ситуации (или при рефакторинге).

>Неверно

```
nav/
    __item/
        nav__item.css
    __link/
        nav__link.css
```

Для выражения вложенности вполне достаточно DOM-дерева:

>Верно

```html
<ul class="nav">
    <li class="nav__item">
        <a class="nav__link"></a>
    </li>
</ul>
```

#### Имя модификатора

Имя модификатора формируется как `имя-модификатора-из-нескольких-слов_имя-значения-из-нескольких-слов`.

Модификаторы бывают булевыми (например, `visible : true`) или представляют собой пару «ключ — значение» (`size : large`, `type : search`). Модификаторы чем-то похожи на атрибуты в HTML.

Значение булевого модификатора в его имени не указывается. Так имя модификатора `visible : true` будет записано, как `visible`.

В модификаторах типа «ключ — значение» имя отделяется от значения одним подчеркиванием, `size_large`.

Модификаторы с одинаковыми именами могут принадлежать как блокам, так и элементам и оказывать на них различное воздействие. Поэтому для определения принадлежности модификатора к его «владельцу», необходимо добавлять неймспейс в виде имени блока или имени блока и его элемента.

Полное имя модификатора создается по схеме:

* Для булевых модификаторов<br>
    `имя-владельца_имя-модификатора`
* Для модификаторов вида «ключ-значение»<br>
    `имя-владельца_имя-модификатора_значение-модификатора`

##### Модификатор блока

Булевый: `имя-блока_имя-модификатора`.

Вид «ключ – значение»: `имя-блока_имя-модификатора_значение-модификатора`.

**Пример**

`lang-switcher_disabled`

`menu_type_radio`

##### Модификатор элемента

Булевый: `имя-блока__имя-элемента_имя-модификатора`.

Вид «ключ – значение»: `имя-блока__имя-элемента_имя-модификатора_значение-модификатора`.

**Пример**

`lang-switcher__item_visible`

`table__box_align_top-left`


## От проблем к решениям

Этот раздел документа посвящен основным проблемам, с которыми сталкиваются и CSS-верстальщики и веб-разработчики, и их решениям с помощью соглашения об именовании в методологии БЭМ.

<a name="bem-simple-code"></a>
### Как уменьшить сложность кода в современном фронтенде?

Распространенная ситуация: пока вы разрабатываете свой проект, называете, казалось бы, очевидные вещи своими именами. Вам понятно, какие компоненты интерфейса для чего служат и за что отвечают.

Например, вы создаете простое навигационное меню:

```
<ul class="nav">
    <li class="item active"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

У вас есть вполне понятные и прозрачные CSS-правила к каждому классу, например:

```
.item
{

}

.active
{

}
```

> Проблема

Пока вы работаете над проектом, вы помните, какие компоненты могут использовать класс `active`. И если проект относится к типу «сделал-отдал-забыл», то такой вид нотации вполне приемлем. Но, если вам придется его поддерживать, то вернувшись к коду через пару месяцев, вы вряд ли сразу вспомните, на что могут повлиять правила данного селектора.

Вполне может оказаться, что в вашем проекте существует еще несколько вариантов использования класса `active` на соседних страницах, например, `.link .active`

В таком случае, чтобы разобраться, можно ли безболезненно изменить стили для `.active`, вам придется просмотреть всю структуру страницы или даже проекта.

А теперь представьте такую же ситуацию с большим проектом — любое изменение потребует огромных временных затрат только на поиск зависимых компонентов.

Пока вы справляетесь с тем количеством данных, которые можно удержать в голове, вы можете успевать вовремя делать все необходимые изменения в проекте. Но как только вы переключаетесь на другой проект или в вашем приложении добавляется еще десяток страниц, такие связи становится сложно проследить.

> Решение

Методология БЭМ помогает вам легко отслеживать все связи между компонентами в пределах вашего проекта только при помощи соглашения по именованию CSS-классов.

Рассмотрим этот же пример, но уже с примененными правилами именования БЭМ-методологии: имя класса `nav` будет означать имя блока, `nav__item` — имя элемента, а `nav__item_active` — имя его модификатора. В таком случае запись будет следующей:

```
<ul class="nav">
    <li class="nav__item nav__item_active"><a class="nav__link">One</a></span></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

И, соответственно, CSS будет иметь такой вид:

```
.nav__item
{

}

.nav__item_active
{

}
```

Имена CSS-классов в таком случае информативны достаточно, чтобы вам не пришлось заглядывать в HTML-код страницы. Имя селектора всегда будет содержать знания о том, что данные правила влияют только на модификацию конкретного блока или его элемента (в данном случае элемента `nav__item`). И вам не придется думать о `.link .active`, так как его CSS-правила будут записаны как `link_active` и не будут зависеть от правил модификатора `active`, относящегося к другой БЭМ-сущности.

Такой подход имеет два потенциальных минуса:

* Результирующий код весит больше. Эту проблему полностью решает `gzip`, который отлично сжимает повторяющиеся последовательности и сводит минус на нет.
* Длинные имена классов писать долго. С этой проблемой помогают справиться автокомплит в редакторе и инструментарий, который автоматически добавляет префиксы (CSS-препроцессоры и шаблонизаторы).

Когда вы видите эти два минуса и больше ничего кроме них, мы предлагаем подумать и выбрать, что важнее — время, необходимое на нажатие клавиш, или время, затраченное на обдумывание архитектуры. Во втором случае БЭМ как раз очень сильно помогает. А первое легко автоматизировать не в урон проекту.

Как результат применения правил по именованию, предложенных БЭМ-методолгией, вы:

* задаете четкие связи между разными сущностями;
* определяете типы сущностей по их именам;
* упрощаете восприятие вашего кода.

Помимо всего вышеперечисленного, использование методологии БЭМ дает вам возможность получить **самодокументируемый код** вашего проекта.

<a name="bem-clarify-code"></a>
#### Самодокументируемый код

Большинство разработчиков сталкивались с переходом на новый проект, который уже какое-то время жил своей жизнью и успел накопить тысячи строк кода, но, как чаще всего бывает, не успел обзавестись подробной документацией. //Даже на образцовых проектах, документация к которым написана добросовестными разработчиками и поддерживается в актуальном состоянии, её часто не хватает. Причина проста: это высокоуровневая семантика, и если не применять никакой методологии, то сам по себе код не даёт инструментов для её описания, поэтому и документация к коду часто не помогает: все методы описаны досконально, а как что работает — зачастую неясно.//

В поддержке кода важно минимизировать время, которое разработчик тратит на то, чтоб понять, как все устроено, где что лежит и как вообще это работает. Порой именно на такое изучение уходит большая часть времени, а вовсе не на реализацию функциональности или исправление ошибки.

Одна из целей БЭМ — рассказать другим разработчикам как можно больше о том, что делает тот или иной код, только по названиям классов в разметке. Читая HTML с небольшим количеством классов внутри, вы можете увидеть взаимодействия во всем коде и между его частями; что-то может быть независимым блоком, что-то дочерним компонентом — элементом этого блока, а что-то может быть его измененной копией — модификатором блока или элемента.

Используя соглашения об именовании сущностей, разработчик сразу сможет понять следующее:

* о каком блоке идет речь;
* с какими элементами блока вы работаете;
* какие модификаторы влияют на его состояние, поведение и внешний вид.

Давайте рассмотрим пример с формой поиска на сайте:

```html
<form class="site-search  full">
    <input type="text" class="field">
    <input type="Submit" value ="Search" class="button">
</form>
```
Это обычные классы, по ним много не скажешь. Многие разработчики привыкли так с ними работать, но с БЭМ можно получить следующее:

```html
<form class="site-search site-search_full">
    <input type="text" class="site-search__field">
    <input type="Submit" value ="Search" class="site-search__button">
</form>
```

Только из имен CSS-классов видно, что есть блок, названный `site-search`, у которого есть вложенный элемент `site-search__field`. Также наглядно видно, что существует модификации блока `site-search`, имеющая свой собственный класс `site-search_full`.

Точно так же просто понять, как устроен и работает описанный выше блок, только глядя на его [файловую систему](#filesystem-doc):

```
// блок
site-search
    // модификаторы
    _full

    // элементы
    __field
    __button
```

Жесткие правила именования в БЭМ позволяют сделать код вашего проекта более прозрачным, однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков и идеально подходит для крупных проектов и больших команд. Не прилагая дополнительных усилий вы получаете самодокументируемый код.

<a name="bem-split-code"></a>
### Меняем CSS-правила одного компонента страницы и при этом не ломаем другие. Реальность или миф?

В стандартной веб-разработке это скорее миф.

Описывая страницу, вы зачастую оперируете одними и теми же понятиями: всевозможные пункты могут встречаться в совершенно различных ситуациях, ссылок на странице может быть множество, при этом какие-то из них должны уводить читателя на другую страницу, какие-то просто облегчать навигацию по странице.

Так, если у вас на странице будет такой код:

```
<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

То CSS-стили к пункту `item` скорее всего будут записаны как:

```
.item
{

}
```

В случае, если на страницу будет необходимо добавить еще какие-то компоненты, включающие в себя пункты, например:

```
<div class="snippets">
    <div class="item">
        <div class="title"></div>
        <img class="thumb" />
    </div>
</div>
```

То вероятность того, что CSS-правила будут оформлены с помощью каскада возрастает, не зря ведь CSS назван Cascading Style Sheets.

```
.item
{

}

.snippets .item
{

}
```

Такой подход кажется вполне удобным и логичным: вы просто доопределяете правила, написанные для `item`.

> Проблема

Ваш код может совершенно безболезненно так существовать и работать до тех пор, пока вы или менеджер проекта не захотите отрефакторить страницу, переместить какие-то пункты меню, использовать написанный код в другом месте отдельно от родителя.

Как только вам понадобится выполнить какое-то из вышеперечисленных действий, вы столкнетесь с проблемой того, что, казалось бы, независимые части вашего кода слишком связаны и влияют друг на друга. Вы не можете исправить какой-то один компонент, не зацепив так или иначе стили другого. В такой ситуации, желая изменить один компонент, вам придется корректировать или полностью переписывать стили всех зависимых от него компонентов, много копировать, отменять стили или вообще удалять их.

Изменив стили для одного компонента страницы, вы можете получить неожиданный «сюрприз» в виде сломанного зависимого неучтенного вами компонента.

> Решение

Опираясь на соглашения по именованию CSS-селекторов в БЭМ, у вас всегда будет возможность внести изменения точечно, не ломая зависимые компоненты. В БЭМ каждый класс имеет уникальное имя и является самодостаточным.

Запишем приведенный в пример код в соответствии с правилами именования БЭМ:

```
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

```
.nav
{

}

.nav__item
{

}

.nav__link
{

}
```

А добавляя на страницу дополнительные пункты, вы также назовете их, ориентируясь на контекст:

```
<div class="snippets">
    <div class="snippets__item">
        <div class="snippets__title"></div>
        <img class="snippents__thumb" />
    </div>
</div>
```

```
.snippets__item
{

}
```

Внесенные изменения в `nav__item` никак не отобразятся на пункте `snippets__item`. Прозрачное именование блоков, элементов и модификаторов и уход от каскадов позволят вносить изменения только в конкретные компоненты и иметь четкое представление, к какому блоку относится каждый элемент и какие стили могут на него влиять.

#### Получается, что в каскадных таблицах стилей нельзя использовать каскад?

Можно. Но нужно понимать, какие последствия это влечет.
Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока (`.nav__hover .nav__link { text-decoration: underline; }``) или, скажем, темы (`.nav_theme_islands .nav__item { line-height: 1.5; }``).

Но в случае использования каскада вы рискуете повысить связанность кода и сделать его реиспользование невозможным, что в будущем может привести к ситуации, когда переписать проще, чем исправить.

<a name="bem-reuse-code"></a>
### Как писать код, который можно переиспользовать?

Можно с уверенностью сказать, что все интерфейсы абсолютно разные. Однако, также уверено можно заявлять и о том, что все интерфейсы состоят примерно из одних и тех же компонентов: все используют кнопки, поля для ввода, списки или ссылки. Только выглядят эти компоненты в разных  случаях совершенно по-разному, а принципиальных отличий в поведении практически нет. Именно поэтому большинство разработчиков так хотят иметь возможность использовать уже написанный код.

Рассмотрим все те же блоки кода:

```
<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```
и

```
<div class="snippets">
    <div class="item">
        <div class="title"></div>
        <img class="thumb" />
    </div>
</div>
```

И следующие CSS-правила для них:

```
.nav
{

}

.item
{

}

.item .link
{

}

.snippets .item
{

}
```

У вас есть отличный список со ссылками, подходящий для вашего следующего проекта. Однако, чаще всего вы не сможете просто взять нужный вам кусок кода и вставить на новое место, так как большинство стилей сломаются из-за использования каскада. В такой форме записи ваши пункты меню скорее всего будут опираться на стили для `.item`, который тоже нужно будет перенести в новый проект, либо придется дополнять правила для переиспользуемого блока.

> Решение

Используя соглашения по именованию БЭМ, вы получаете следующие уникальные, специфичные только для блока `nav` CSS-правила:

```
.nav
{

}

.nav__item
{

}

.nav__link
{

}
```

Блок `snippets` также будет иметь свои независимые правила:

```
.snippet
{


}

.snippet__item
{

}
```

Таким образом, общий элемент `item` получает уникальные CSS-стили благодаря неймспейсам в виде имени блока.

Разбивая код на логически независимые части (блоки), вы создаете кубики для конструктора, которые легко перемещать в пределах одной страницы, переносить на другие страницы или в другие проекты.

Независимость блоков касается не только CSS. В методологии БЭМ блок является абсолютно независимой и самодостаточной единицей. Он знает о себе все: свой внешний вид (CSS), поведение (JavaScript и шаблоны) и перечень блоков, с которыми ему необходимо взаимодействовать (зависимости).

// сослаться на док «Зачем БЭМ в JavaScript»

Уникальность имен классов, основанное на правилах именования БЭМ, позволяет блокам не зависеть друг от друга.


### Миксы или как разместить несколько сущностей на одном DOM-узле

Воспользуемся еще раз нашим примером:

 ```
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

В нем мы используем ссылку в качестве элемента блока `nav`. Но ссылка может быть и отдельным блоком на странице. **Как отличить — делать блок или элемент?**

В такой ситуации удобно воспользоваться [миксом](definitions-doc) — то есть смешать на одном DOM-узле несколько блоков (или элементов/модификаторов) одновременно. В нашем случае это будет блок `link` и элемент `nav__link`. Рассказываем зачем:

Предыдущий пример вполне может выглядеть так:

```html
<ul class="nav">
    <li class="nav__item">
        <a class="link nav__link"></a>
    </li>
</ul>
```

При этом все общее, что есть у всех ссылок на проекте, будет описано в блоке `link`, а особенности, присущие только ссылке внутри `nav` — для `nav__link`.

<a href="bem-fast"></a>
### Скорость рендеринга и селекторы большой вложенности в CSS

Как уже говорилось выше применение каскада в CSS вполне оправдано в случае стандартного подхода к разработке, но использование селекторов большой вложенности может значительно снизить быстродействие вашего сайта.

Конечно, на маленьких и средних страницах CSS не может сильно влиять на скорость. Однако, если ваш проект растет (а большинство разработчиков стремятся именно к этому), вы уже не можете не учитывать этот фактор, влияющий на скорость. К тому времени, когда вы осознаете, что CSS замедляет работу проекта, будет очень сложно или практически невозможно начинать оптимизацию CSS-правил.

> Решение

Правила именования в БЭМ созданы таким образом, что каждый БЭМ-класс имеет уникальное имя и является самодостаточным – разные блоки никогда не пересекаются по именам классов.

Это означает, что вам, скорее всего, достаточно указать один класс, чтобы:

* описать стили самого блока;
* описать стили любого элемента внутри блока;
* добавить дополнительные стили или переопределения с помощью модификатора.

Большинство браузеров начинают применять селектор с «правой части» (охватывающей чаще всего большее множество узлов) и затем уточняют полученную выборку, фильтруя ее применением оставшихся правил. Чем больше шагов фильтрации требуется, тем больше времени это занимает. Современные браузеры очень хорошо оптимизированы для этих задач, но последние версии установлены далеко не у всех, и мобильные устройства всегда могут вести себя иначе — а селекторы, состоящие из одного класса, как минимум относятся к самым быстрым селекторам из всех возможных.

Конечно же БЭМ не отменяет каскад в CSS! Однако он значительно сокращает его использование. Существуют сложные случаи, когда необходимо указать два и более классов в одном селекторе. Например, сочетание модификаторов, внутренние зависимости элементов или влияние модификатора блока на стили отдельных его элементов:

```
.menu-item_disabled .menu-item__label
{
   display: none;
}
```

Но поскольку БЭМ превращает CSS из простого набора классов в семантическую модель проекта, то скорее всего потребность переопределить заданные стили будет зависеть от модификатора, который, как и положено в БЭМ, будет иметь свою уникальное имя. Таким образом нам удается сохранить специфичность CSS-правил.





<a name="name-scheme"></a>
### Распространенные схемы именования по БЭМ

**Классический стиль**

`block-name__elem-name_mod-name_mod-val`

Использование описано в предыдущей главе. Данный стиль имеет один существенный плюс – все предлагаемые инструменты [платформы БЭМ](), в том числе и с открытыми исходниками, ориентируются именно на такое именование.

**Стиль Гарри Робертса**

`block-name__elem-name--mod-name`

* использование дефиса в именах;
* отделение имени элемента от блока с помощью двух подчеркиваний;
* отделение булевых модификаторов с помощью двух дефисов;
* модификаторы вида «ключ-значение» не используются.

**Стиль без подчеркиваний**

`blockName-elemName--modName-modVal`

* использование в именах «верблюжего регистра»;
* отделение имени элемента от блока с помощью одного дефиса;
* отделение модификаторов с помощью двух дефисов;
* отделение значения модификатора с помощью одного дефиса.


Хозяйке на заметку


### Дополнительные правила БЭМ-нотации Основные положения соглашения по именованию методологии БЭМ

#### Не используем селекторы, кроме селекторов класса

БЭМ-методология



#### Не используем каскад




#### Не используем id.

#### Не используем вложенность элементов.

Выводы

мы устанавливаем связи между элементами за счет одного только именования классов







Возмоность мыслить и работать на уровне сущностей и не слишком зависеть при этом от структуры страницы позволила разбить содержимое на логические блоки и сделать их независимыми друг от друга.

Основная идея схожа с принципами ООП — иметь возможность создать ограниченное число повторно используемых компонентов, которые могут содержать целый диапазон разных типов контента. Такой подход позволяет создавать более надежные, гибкие и пригодные для повторного использования компоненты.

Разделение на блоки (модульный подход) позволяет легче распараллеливать разработку, и защищает от ситуации «единоличного контроля» разработчика над важной частью проекта, поскольку сам БЭМ-подход поощряет модульность. Кроме этого, в любом самом сложном коде базовые приёмы работы с данными (БЭМ-дерево, модификаторы, взаимодействие блоков) будут одинаковыми; разбираться в таком коде проще, поддерживать его — легче.



