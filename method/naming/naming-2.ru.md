# Соглашение об именовании

Методология БЭМ опирается на ряд соглашений и правил по именованию селекторов, соблюдение которых решает многие насущные для веб-разработчика проблемы.

* [Как понять, о какой конкретно сущности идет речь? Определение всех частей сущности в отрыве от контекста.](#)
* [Как избежать взаимного влияния компонентов на особенности друг друга, не используя при этом Shadow Dom и не завися от совместимости с браузерами?](#)
* [Как улучшить скорость рендеринга?](#)
* [Как уменьшить сложность кода?](#)
* [Как начать переиспользовтаь код?](#)
* [Как упростить рефакторинг?](#)

В этой статье мы расскажем вам, как с помощью соглашений по именованию БЭМ можно решить все эти проблемы и начать писать код, который понятен не только вам, но и другим разработчикам.

## Немного о главном

### Понятие БЭМ-сущностей и для чего они нужны

#### Блок

[Блок](ссылка на definitions) – это ключевая сущность БЭМ-методлологии. Блок – это независимый компонент страницы, логически и функционально. Он содержит всю информацию о себе и своих элементах.

Блоки можно свободно перемещать по странице, между разными страницами или разными проектами. Блок имеет публичный API для взаимодействия с другими блоками, но детали его внутренней реализации скрыты от пользователей.

Блоки могут быть как совершенно простыми, например, `кнопка`, так и достаточно сложными, содержащими в себе другие блоки и дополнительные элементы, например, `шапка`. В интерфейсе может одновременно присутствовать несколько экземпляров одного и того же блока (например, разные кнопки или несколько меню).

#### Элемент

[Элемент](ссылка на definitions) – это часть блока, отвечающая за его определенную функцию.
Элементы не могут существовать и использоваться в отрыве от блока, к которому они относятся.

Примерами элементов блока могут служить пункты меню, где само меню – это блок, а вложенные в него пункты – это элементы этого блока. Пункт, вырванный из контекста блока меню, сам по себе не имеет никакого смысла.

#### Модификатор

[Модификатор](ссылка на definitions) — это свойство блока или элемента, определяющее их внешний вид, состояние или поведение. Модификаторы относятся или к блоку, или к элементу конкретного блока. Ситуация, когда один модификатор относится и к блоку, и к его элементу невозможна.

Модификаторы бывают булевыми (например, `visible : true` или `false`) или представляют собой пару «ключ — значение» (`size : large`, `medium`, `small`). Это чем-то похоже на атрибуты в HTML, но всё-таки не то же самое. У сущности может быть несколько модификаторов, если эти модификаторы описывают разные вещи.

### Соглашения об именовании

Методология БЭМ предоставляет набор рекомендаций и правил по именованию CSS-селекторов. Командой БЭМ разработана [схема именования](#ссылка на платформенную часть, где описывается парвила нашей схемы про нижние подчеркивания и тире), которая учитывает все требования. Примеры в данном разделе будут приводиться с учетом данной схемы.

Существует ряд других схем, основанных на правилах БЭМ. Самые известные из них приведены в разделе [Распространенные схемы именования по БЭМ](#name-scheme).

**Ограничения**

* Не используем каскад.
* Не используем селекторы, кроме селекторов класса.
* Не используем id.
* Не используем вложенность эелементов.

#### Имя блока

Имя блока является ключевым идентификатором, определяющим его назначение. Все зависимые от блока элементы и модификаторы будут опираться на него при формировании своих собственных имен.

Имя блока служит неймспейсом для его елементов и модификаторов.

Имя блока формируется как `имя-блока` или `префикс-имя-блока`.

**Примеры**

`header`

`button`

`menu`

##### Использование префиксов в именах блоков

Иногда для большей информативности и простоты восприятия кода в имена блоков могут добавляться различные префиксы.

Так, исторически сложившейся традицией в БЭМ было использование префикса `b-` (от `block`) для обозначения блока с визуальным представлением. А префикс `i-` или `js-` (от `include` и `javascript`) означал, что блок не имеет визуальной реализации и является вспомогательным для построения других блоков. Но так как сейчас большая часть блоков имеет JS-представление, то уже нет необходимости отличать технологии реализации блока на уровне имен.

Методология БЭМ не призывает вас использовать префиксы, но и не выступает категорически против. Объективно необходимости в префиксах нет, но каждый может выбирать то, что ему, проекту или команде удобнее и/или привычнее.

**Пример**

`b-link`

#### Имя элемента

Полное имя элемента формируется так, чтобы из него можно было определить принадлежность данного элемента к конкретному блоку.

Полное имя элемента создается по схеме:

`имя-блока__имя-элмента`

**Пример**

`menu__menu-item`

`nav__item`

`table__row`

Если блок имеет несколько одинаковых элементов, как в случае пунктов меню, то все они будут иметь одинаковое имя.

_________________________________________

**Важно помнить!** В методологии БЭМ не существует элементов элементов.

Неймспейсом служит только имя блока. Отражать вложенность в именах элементов не имеет смысла, так как это не позволит легко вынуть один элемент из другого при повторном использовании блока в другой ситуации (или просто при рефакторинге).

#### Имя модификатора

Полное имя модификатора формируется так, чтобы из него можно было определить принадлежность данного модификатора к его «владельцу». Владельцем может быть блок или элемент.

Схема именования:

* Для булевых модификаторов<br>
    `имя-владельца_имя-модификатора`
* Для модификаторов вида «ключ-значение»<br>
    `имя-владельца_имя-модификатора_значение-модификатора`

**Важно помнить!** Один и тот же модификатор не может быть применен одновременно и к блоку, и к его элементу.

##### Модификатор блока

Булевый: `имя-блока_имя-модификатора`

Вид «ключ – значение»: `имя-блока_имя-модификатора_значение-модификатора`

**Пример**

`menu_focused`

`menu_type_radio`

##### Модификатор элемента

Булевый: `имя-блока__имя-элемента_имя-модификатора`

Вид «ключ – значение»: `имя-блока__имя-элемента_имя-модификатора_значение-модификатора`

**Пример**

`table__box_disabled`

`table__row_align_left`

### Дополнительные ограничения БЭМ-нотации



<a name="name-scheme"></a>
### Распространенные схемы именования по БЭМ

**Классический стиль**

`block-name__elem-name_mod-name_mod-val`

Использование описано в предыдущей главе. Данный стиль имеет один существенный плюс – все предлагаемые инструменты в БЭМ-платформе, в том числе и с открытыми исходниками, ориентируются именно на такое именование.

**Стиль Гарри Робертса**

`block-name__elem-name--mod-name`

* использование дефиса в именах;
* отделение имени элемента от блока с помощью двух подчеркиваний;
* отделение булевых модификаторов с помощью двух дефисов;
* модификаторы вида «ключ-значение» не используются.

**Стиль без подчеркиваний**

`blockName-elemName--modName-modVal`

* использование в именах «верблюжего регистра»;
* отделение имени элемента от блока с помощью одного дефиса;
* отделение модификаторов с помощью двух дефисов;
* отделение значения модификатора с помощью одного дефиса.

## От проблем к решениям

Данный раздел включает решения большинства проблем с помощью использования БЭМ-нотации, с которыми сталкиваются CSS-верстальщики и веб-разработчики.

### Без контекста непонятно, какой компонент интерфейса описан в классе.

Когда вы разрабатываете свой проект и называете казалось бы очевидные вещи своими именами, все идет хорошо и понятно.

<ul class="nav">
    <li class="item"><span class="active"><a class="link">One</a></span></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>

 У вас есть вполне понятные и прозрачные CSS-правила к каждому классу, например:

.item
{

}

.active
{

}

Проблема

Пока вы работаете со страницей или проектом вы помните и понимаете, какие компонетны используют класс `active`. И если проект относится к типу «сделал-отдал-забыл», то такой вид нотации вполне приемлим. Но если вам придется поддерживать эту страницу, то вернувшись к коду через пару месяцев, вы вряд ли сразу вспомните, на что могут повлиять правила данного селектора. Чтоб разобраться, можно ли их безболезненно поменять, вам придется просмотреть всю структруру страницы или проекта (если вы переиспользовали данное правило).

Решение

Используя БЭМ, вы будете сразу видеть четкие связи. В БЭМ-методологии селектор `item` будет обозначть имя блока, а селектор `active` будет являться модификатором этого блока. В таком случае запись будет следующей:

<ul class="nav">
    <li class="item item_active"><a class="link">One</a></span></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>

И, соответственно, CSS будет иметь такой вид:

.item
{

}

.item_active
{

}

CSS будет информативен достаточно, чтобы вам не пришлось заглядывать в HTML страницы. Вы всегда будете уверены, что для данные правила влияют только на модификацию блока `item`.

### Меняем CSS-правила одного компонента страницы и при этом не ломаем другие. Реальность или миф?

В стандарнтой веб-разработке это скорее миф.

Описывая страницу, вы зачастую оперируете одними и теми же понятиями: всевозможные пункты (`item`) могут встречаться в совершенно различных ситуациях, ссылок на странице может быть множество, при этом какие-то из них должны уводить читателя на другую страницу, какие-то просто облегчать навигацию по странице.

Так, если у вас на странице будет такой код:

<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>

То CSS-стили к пункту `item` будут записаны так:

.item
{

}

В случае, если на страницу будет необходимо добавить еще какие-то компоненты, состоящие из пунктов, например:
<div class="snippets">
    <div class="item">
        <div class="title"></div>
        <img class="thumb" />
    </div>
</div>

То скорее всего CSS-правила будут оформлены с помощью каскада. Не зря ведь CSS назван Cascading Style Sheets.

.item
{

}

.snippets .item
{

}

То есть вы просто доопределите правила, написанные для `item`.

Проблема

И страница может совршенно безболезненно так существовать и работать до тех пор, пока вы или менеджер проекта не захотите отрефакторить страницу, переместить какие-то пункты меню, использовать написанный код в другом месте отдельно от родителя. Как только вам понадобится выполнить какое-то из вышеперечисленных действий, вы столкнетесь с проблемой того, что ваш код слишком связан и влияет друг на друга. Вы не можете исправить какой-то один компонент, не зацепив так или иначе стили друго. В такой ситуации, желая изменить один компонент, вам придется корректировать или полностью переписывать стили всех зависимых от него компонентов, много копировать, удалять или вообще отменять стили.

Изменив стили для одного компонента страницы, вы можете получить неожиданный «сюрприз» в виде сломанного другого компонента.

Решение

Опираясь на соглашения по именованию CSS-селекторов в БЭМ, у вас всегда будет возможность внести изменения точечно, не ломая зависимые компненты, потому как в БЭМ каждый класс имеет уникальное имя и является самодостаточным.

Запишем привденный в пример код в соответствие с правилами именования БЭМ:

<ul class="nav">
    <li class="nav__item"><a class="link nav__link">One</a></li>
    <li class="nav__item"><a class="link nav__link">Two</a></li>
    <li class="nav__item"><a class="link nav__link">Three</a></li>
</ul>

В таком случае CSS для пункта в списке `nav` будет независим от CSS-правил для самого `nav`:

.nav
{

}

.nav__item
{

}

А добавляя на страницу дополнительные пункты, вы также назовете их, ориентируясь на контекст:

<div class="snippets">
    <div class="snippets__item">
        <div class="snippets__title"></div>
        <img class="snippents__thumb" />
    </div>
</div>

.snippets__item
{

}

Внесенные изменения в `nav` никогда не повлияют на элемент `nav__item`, а изменения `nav__item` никак не отобразятся на пункте `snippets__item`. Прозрачное именование блоков, элементов и модификаторов и уход от каскадов позволят вносить изменения только в конкретные кмпоненты и иметь четкое представление, к какому блоку относится каждый элемент и какие стили могут на него влиять.


### Скорость рендеринга и селекторы большой вложенности в CSS

Как уже говорилось выше применение каскада в CSS вполне оправдано во многих случаях, но



Селекторы большой вложенности — не лучший способ ускорить ваш сайт, особенно если вы поддерживаете старые браузеры. Кроме этого, такие селекторы больше опираются на структуру документа и часто создают конфликты стилей, влияя на элементы, которые изначально затрагивать не планировалось. Однако каскад в CSS не так ценен и нужен, как мы привыкли думать.

Как это возможно и почему это важно? Разве неверно, что каскад должен использоваться в CSS, иначе зачем они называются Cascading Style Sheets?

Вернёмся к правилам именования и вспомним, что каждый БЭМ-класс имеет уникальное имя и является самодостаточным. За редкими исключениями он не зависит ни от имён тегов, ни от идентификаторов, и разные блоки никогда не пересекаются по именам классов. Это означает, что вам, скорее всего, достаточно указать один (и только один!) класс, чтобы:

описать стили самого блока;
описать стили любого элемента внутри блока;
добавить дополнительные стили или переопределения с помощью модификатора.
Это покрывает большую часть CSS-задач, которые возникают при вёрстке средней сложности. При этом мы максимально упрощаем браузеру работу по разбору селектора и нахождению элементов, которые ему соответствуют. Большинство браузеров начинают применять селектор с «правой части» (охватывающей чаще всего большее множество узлов) и затем уточняют полученную выборку, фильтруя её применением оставшихся правил. Чем больше шагов фильтрации требуется, тем больше времени это занимает. Современные браузеры очень хорошо оптимизированы для этих задач, но не у всех установлены последние версии, и мобильные устройства всегда могут вести себя иначе — а селекторы, состоящие из одного класса, как минимум относятся к самым быстрым селекторам из всех возможных.

На маленьких и средних страницах CSS редко является главной проблемой замедления быстродействия, но набор CSS-правил должен применяться заново при каждом изменении документа. Когда ваш проект растёт, скорость работы CSS рано или поздно станет важным фактором. Специалисты по юзабилити любят повторять, что 250 миллисекунд — это порог, в случае превышения которого действие не воспринимается как мгновенное. Чем быстрее ваш CSS изначально, тем больше пространства для манёвра будет у вас, чтобы поддерживать ощущение «всё летает».

Получается, БЭМ отменяет каскад в CSS?! Если всерьёз, то, конечно же, нет. Есть случаи, когда каскад нужен, — если требуется указать два или более классов в одном селекторе. Например, если модификатор блока влияет на стили отдельных его элементов:

.b-text-input_disabled .b-text-input__label
{
   display: none;
}
Но поскольку мы имеем не просто набор классов, а семантическую модель, другое правило, которому может потребоваться переопределить заданные здесь стили, тоже с высокой вероятностью будет зависеть от модификатора (но другого), однако специфичность-то всё равно останется та же самая! А это значит, что мы опять можем опираться только на порядок следования правил.

Есть и другие примеры, когда каскад необходим (внутренние нетривиальные зависимости элементов, сочетания модификаторов, CSS-хаки). Живые проекты всегда богаче и сложнее, чем любая методология (даже БЭМ!), но подобные стили вряд ли потребуются вам часто.


[Как понять, о какой конкретно сущности идет речь? Определение всех частей сущности в отрыве от контекста.](#)
* [Как избежать взаимного влияния компонентов на особенности друг друга, не используя при этом Shadow Dom и не завися от совместимости с браузерами?](#)
* [Как улучшить скорость рендеринга?](#)
* [Как уменьшить сложность кода?](#)
* [Как начать переиспользовтаь код?](#)
* [Как упростить рефакторинг?](#)


















# Вкладывание элементов в элементы и другие тонкости

По мотивам [обсуждения в твиттере](https://twitter.com/delaz/status/554610743531036672) с подачи [@delaz](https://twitter.com/delaz/), решили написать пост и собрать еще вопросов и тем для разъяснения, которые в будущем планируем добавить в раздел про методологию.

Что у нас получилось?

1. [БЭМ — это не про префиксы](#bem-not-prefixes).
2. [БЭМ — это не про длинные названия классов](#bem-not-long-classes).
3. [Нельзя использовать элементы элементов в нейминге](#no-elems-of-elems).
4. [Миксы](#mixes).
5. [БЭМ  не запрещает каскад (но и не приветствует)](#bem-no-cascade).
6. [Как понять, когда делать блок, а когда — элемент](#block-or-elem).

Пойдем по порядку, а вы задавайте вопросы или дополняйте список в комментариях. Ответы будем выносить в пост.

**«БЭМ — это длинные имена классов. b-button — это длинно!»**
<a id="bem-not-prefixes"></a>
Отвечаем: БЭМ не навязывает префиксы. Чтобы писать хорошо поддерживаемый и реиспользуемый код, префиксы совершенно не нужны. Исторически они появились в переходный период для того, чтобы отличать новый код, написаный по БЭМ, от старого. Со временем мы от них отказались. Если посмотреть в [код](https://github.com/bem/bem-components/tree/v2/common.blocks), можно увидеть, что префиксов там нет.

**«А как же префикс js- или i- для блоков без визуального представления?»**
Когда-то можно было сверстать сайт практически без JS-кода. Сейчас большая часть блоков имеет JS-представление. Глядя на текущую ситуацию мы поняли, что нет нужды как-то отличать технологии реализации блока на уровне нейминга. Посмотрите, к примеру, на Web Components. Объективно необходимости в префиксах нет, но каждый волен выбирать, что ему, проекту или команде удобнее и/или привычнее.

<a id="bem-not-long-classes"></a>
**«Префиксы — ладно. А просто длинные названия блоков?»**

В этом и похожих случаях вы можете использовать классы типа `btn` вместо `button`. Это никак не помешает вам разрабатывать по БЭМ.
Все как с названием переменных в JS: `context`, `ctx` или `c`. Но помните, вам, вашим коллегам и тем, кто будет разрабатывать и поддерживать проект после вас это предстоит читать, понимать и с этим работать ;)

Остается **вопрос про неймспейсы** — мы пишем имя блока перед именем элементов (`button__icon`) и модификаторов (`button_active`).

Если декомпозировать «проблему», можно выделить 2 потенциальных минуса:
* Результирующий код, который приходится гонять по сети, весит больше. Тут на помощь приходит `gzip`, который отлично жмет повторяющиеся последовательности и сводит минус на нет.
* Приходится больше кнопок нажимать на клавиатуре. Здесь помогают автокомплит в редакторе и инструментарий, который автоматически добавляет префиксы (CSS-препроцессоры и шаблонизаторы).
Когда вы видите эти два минуса и больше ничего кроме них, мы предлагаем подумать и выбрать, что важнее — время, необходимое на нажатие клавиш, или время, затраченное на обдумывание архитектуры. Во втором случае БЭМ как раз очень сильно помогает. А первое легко автоматизировать не в урон проекту.

И тогда, благодаря неймспейсам, будет решено следующее:
1. Исчезнет опасность случайно «задеть» внутреннее устройство блока. Мы получим аналог скоупа в JS, но для CSS. Для этого в Web Components придумали Shadow DOM, но в действительности простого добавления имени блока достаточно, чтобы получить тот же результат без лишних телодвижений.

<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>

<div class="snippets">
    <div class="item">
        <div class="title"></div>
        <img class="thumb" />
    </div>
</div>

.item
{

}

.snippets .item
{

}

VS.

<ul class="nav">
    <li class="nav__item"><a class="link nav__link">One</a></li>
    <li class="nav__item"><a class="link nav__link">Two</a></li>
    <li class="nav__item"><a class="link nav__link">Three</a></li>
</ul>

.nav__item
{

}

2. С первого взгляда на любой класс, хоть в CSS, хоть в HTML, хоть в любой другой технологии реализации блока, мы тут же поймем, к какому блоку он относится и какую задачу решает. Сравните: `active` (на что повлияет этот класс?) VS. `input_active` или `item` VS. `nav__item`.

<input class="input_active">

css
.active
{

}



----------------------------------------------------------------------------------

1. Не используем каскад
2. Не используем селекторов, кроме селекторов, скажем, на классы

div
{

}

.content div
{}

.snippets
{

}

3. Не используем id

<div class="header">
    <div id="logo"></div>
</div>


<a id="no-elems-of-elems"></a>
**«Что вы скажете на nav__item__link? Все равно длинно»**

Да. И к тому же не по БЭМу :)

Неймспейсом служит только имя блока. А отражать вложенность в именах элементов не нужно.
Это не только длинно, но еще и не позволит при повторном использовании блока в другой ситуации (или просто при рефакторинге) легко вынуть один элемент из другого.
Плоская структура касается не только нейминга, но и расположения кода в файловой системе:
```
nav/
    __item/
        nav__item.css
    __link/
        nav__link.css
```

Для выражения вложенности вполне достаточно DOM-дерева:
```html
<ul class="nav">
    <li class="nav__item">
        <a class="nav__link"></a>
    </li>
</ul>
```

<a id="mixes"></a>
**«Логично. Как отличить — делать блок или элемент? Например, nav__link — это элемент меню или самостоятельный блок link, который будет использоваться и в других местах на странице?»**

Тут нам на помощь приходят **миксы** — возможность смешать на одном DOM-узле несколько блоков (или элементов/модификаторов) одновременно.

Предыдущий пример вполне может выглядеть так:
```html
<ul class="nav">
    <li class="nav__item">
        <a class="link nav__link"></a>
    </li>
</ul>
```

При этом все общее, что есть у всех ссылок на проекте, будет описано в блоке `link`, а особенности, присущие только ссылке внутри `nav` — для `nav__link`.

**«Почему нельзя стилизовать ссылки каскадом через .nav__item .link?»**

1. Это несемантично. А если там в будущем окажется не ссылка вовсе?
2. Во-вторых, это влечет за собой дополнительные сложности, ведь каскад затронет и вложенные сущности. Например, если в будущем вы захотите усложнить архитектуру или добавить выпадающее меню.
3. Наконец, структура может поменяться и `nav__item` совсем исчезнуть.

<a id="bem-no-cascade"></a>
**«Получается, что в каскадных таблицах стилей нельзя использовать каскад?»**

Можно. Но нужно понимать, какие последствия это влечет.
Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока (`.nav__hover .nav__link { text-decoration: underline; }``) или, скажем, темы (`.nav_theme_islands .nav__item { line-height: 1.5; }``).

Но в случае использования каскада вы рискуете повысить связанность кода и сделать его реиспользование невозможным, что в будущем может привести к ситуации, когда переписать проще, чем исправить.

<a id="block-or-elem"></a>
**«Как в принципе отличать, где блок, а где элемент?»**

Если хочется переиспользовать кусок кода вне контекста родителя — это точно блок.
Если кусок кода не имеет смысла без родителя — это скорее всего элемент.
Аналогией служит Shadow DOM в Web Components.

Исключением может быть ситуация, когда у такого элемента оказывается слишком богатый внутренний мир и возникает желание сделать его собственные элементы. Тогда это можно представить как служебный «приватный» блок.


Что скажете? Наши ответы помогут вам разобраться в ваших ситуациях или же нам стоит подумать над чем-то еще? Будет очень здорово получить от вас вопросы или же примеры, которые мы сможем объяснить. А потом вынести всю эту полезную информацию в раздел сайта.

Очень ждем ваших комментариев!

