# Соглашение по именованию

Методология БЭМ оперирует понятиями БЭМ-сущностей: [блоков](../definitions/definitions.ru.md#bem-block), [элементов](../definitions/definitions.ru.md#bem-element) и [модификаторов](../definitions/definitions.ru.md#bem-mods). И прежде чем начать с ними работать, необходимо ознакомиться с правилами их именования.

Соглашение по именованию позволяет всегда одинаково называть БЭМ-сущности независимо от того, пишете ли вы CSS, JavaScript, шаблоны или работаете с файловой системой проекта. Благодаря общим принципам вы всегда понимаете из названия, о какой БЭМ-сущности идет речь.

БЭМ-методология задает ряд соглашений и правил по именованию CSS-селекторов, соблюдение которых решает многие насущные для веб-разработчика проблемы:

* [Как уменьшить сложность кода.](#bem-simple-code)
* [Как начать переиспользоваь код.](#bem-reuse-code)
* [Как избежать взаимного влияния компонентов друг на друга и упростить рефакторинг.](#bem-split-code)
* [Как понять, о какой конкретно сущности идет речь. Определение всех частей сущности в отрыве от контекста.](#bem-clarify-code)
* [Как улучшить скорость рендеринга.](#bem-fast)

В этой статье мы расскажем, как простые правила именования БЭМ-сущностей решают все вышеперечисленные проблемы и делают код понятным не только его автору, но и другим разработчикам.

### Соглашения по именованию CSS-селекторов

Основная идея соглашения — сделать имена CSS-селекторов более понятными и дать возможность разработчикам с их помощью различать блоки, элементы и модификаторы.

Рассмотрим простой CSS-селектор `menuitemvisible`. Такую запись сложно воспринимать особенно при быстром просмотре. Напрашивается добавление какого-нибудь разделителя, например, `menu-item-visible` или `menuItemVisible`. В таком виде имя селектора становится намного понятнее за счет явного выделения логических частей: отдельные имена легко вычленить из общей записи. Достаточно легко предположить, что `menu` в данном случае, скорее всего, окажется блоком, `item` — элементом, а `visible` — модификатором. В таком простом примере все очевидно, однако жизненные ситуации зачастую намного сложнее и не столь однозначны.

Методология БЭМ использует жесткие правила именования CSS-селекторов, которые помогают не только легко воспринимать имена сущностей, но и точно определять их типы.

Приведенные в данном разделе правила и примеры основаны на каноническом стиле именования, описанном ниже. Однако он не исключает наличия [альтернативных схем](#name-scheme).

#### Общие положения

* Все имена БЭМ-сущностей записываются в нижнем регистре.
* Для разделения слов в именах БЭМ-сущностей используется **дефис** (-).
* Для хранения информации о блоках, элементах и модификаторах используются CSS-классы.

**Пример**

Имя блока — `search-form`.
Имя элемента — `itput-field`.
Имя модификатора — `has-clear`.

> Существуют и другие варианты использования CSS-селекторов.

#### Имя блока

Имя блока формируется как `блок`.

Имя блока служит [неймспейсом](https://ru.wikipedia.org/wiki/Пространство_имён) для его элементов и модификаторов.

**Примеры**

`lang-switcher`

`button`

`menu`

>##### Использование префиксов в именах блоков

>Иногда для большей информативности и простоты восприятия кода в имена блоков могут добавляться различные префиксы.

>Так, [исторически сложившейся традицией](https://ru.bem.info/method/history/#Префиксы) в БЭМ было использование префикса `b-` (от `block`) для обозначения блока с визуальным представлением. А префикс `i-` или `js-` (от `include` и `javascript`) означал, что блок не имеет визуальной реализации и является вспомогательным для построения других блоков. Но так как сейчас большая часть блоков имеет JS-представление, то уже нет необходимости отличать технологии реализации блока на уровне имен.

>**Пример**

>`b-link`

#### Имя элемента

Имя элемента формируется также, как и имя блока — `элемент`.

Для определения принадлежности элемента к блоку используется неймспейс в виде имени блока, который отделяется от имени элемента двумя подчеркиваниями (__).

Полное имя элемента создается по схеме:

`блок__элмент`

**Пример**

`lang-switcher__item`

`menu__group-title`

`menu__item`

Если блок имеет несколько одинаковых элементов, как в случае пунктов меню, то все они будут иметь одинаковые имена.

_________________________________________

**Важно!** В методологии БЭМ не существует элементов элементов.

Неймспейсом служит только имя блока. Отражать вложенность в именах элементов не имеет смысла, так как это не позволит легко вынуть один элемент из другого при повторном использовании блока в другой ситуации (или при рефакторинге).

>Неверно

```css
.nav__item__link {}
```

**Note** Для выражения подобной связи можно указать более точное имя элемента.

>Верно

```css
.nav__item-link {}`
```

Для выражения вложенности вполне достаточно DOM-дерева:

```html
<ul class="nav">
    <li class="nav__item">
        <a class="nav__link"></a>
    </li>
</ul>
```

#### Имя модификатора

Имя модификатора формируется как `модификатор_значение`.

Модификаторы одтеляются от имени блока или имени элемента нижним подчеркиванием (_).

Виды модификаторов:

* Булевый модификатор. Значение такого модификатора не указывается.
 (например, `_visible`)

* Модификатор типа «ключ — значение». Значение модификатора отделяется от имени модификатора одним подчеркиванием (_).
(например, `_size_large`, `_type_search`)

Полное имя модификатора создается по схеме:

* Для булевых модификаторов<br>
    `имя-владельца_имя-модификатора`
* Для модификаторов вида «ключ-значение»<br>
    `имя-владельца_имя-модификатора_значение`

##### Модификатор блока

Булевый: `имя-модификатора`.

Вид «ключ – значение»: `имя-блока_имя-модификатора_значение`.

**Пример**

`lang-switcher_disabled`

`menu_type_radio`

##### Модификатор элемента

Булевый: `имя-блока__имя-элемента_имя-модификатора`.

Вид «ключ – значение»: `имя-блока__имя-элемента_имя-модификатора_значение`.

**Пример**

`lang-switcher__item_visible`

`table__box_align_top-left`


## От проблем к решениям

Рассмотрим основные проблемы, с которыми сталкиваются веб-разработчики, и их решения с помощью соглашения об именовании в методологии БЭМ.

<a name="bem-simple-code"></a>
### Как уменьшить сложность кода в современном фронтенде

Распространенная ситуация: пока разработчик работает над проектом, он называет, казалось бы, очевидные вещи своими именами. Ему понятно, какие компоненты интерфейса для чего служат и за что отвечают.

Например, для создания простого навигационного меню могут использоваться следующие имена классов:

```html
<ul class="nav">
    <li class="item active"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

К ним будут написаны вполне понятные и прозрачные CSS-правила, например:

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

> Проблема

Пока работа над проектом продолжается, разработчик помнит, какие компоненты могут использовать класс `active`. И если проект относится к типу «сделал-отдал-забыл», то такой вид нотации вполне приемлем. Но, если проект придется поддерживать, то вернувшись к коду через пару месяцев, мало кому удается сразу вспомнить, на что могут повлиять правила данного селектора.

Вполне может оказаться, что в проекте существует еще несколько вариантов использования класса `active` на других страницах, например, `.link.active`.

В таком случае, чтобы разобраться, можно ли безболезненно изменить стили для `.active`, разработчику придется просмотреть всю структуру страницы или даже проекта.

А теперь представьте такую же ситуацию с большим проектом — любое изменение потребует огромных временных затрат только на поиск зависимых компонентов.

Пока разработчик справляется с тем количеством данных, которые можно удержать в голове, он можете успевать вовремя делать все необходимые изменения в коде. Но при переключении на другой проект или добавлении в существующий еще десятка страниц, такие связи становится сложно проследить.

> Решение

Методология БЭМ помогает легко отслеживать все связи между компонентами в пределах проекта только при помощи соглашения по именованию CSS-классов.

Рассмотрим этот же пример, но уже с примененными правилами именования БЭМ-методологии: класс `nav` будет обозначать имя блока, `nav__item` — имя элемента, а `nav__item_active` — имя его модификатора. В таком случае запись будет следующей:

```html
<ul class="nav">
    <li class="nav__item nav__item_active"><a class="nav__link">One</a></span></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

И, соответственно, CSS будет иметь такой вид:

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}

.nav__item_active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

Имена CSS-классов в таком случае достаточно информативны, чтобы разработчику не пришлось заглядывать в HTML-код страницы. Cелектор всегда будет содержать знания о том, что данные правила влияют только на изменение конкретного блока или его элемента (в данном случае элемента `nav__item`). Разработчику не придется думать о `.link.active`, так как его CSS-правила будут записаны как `.link_active` и не будут зависеть от правил модификатора `active`.

Такой подход имеет два потенциальных минуса:

* Результирующий код весит больше. Эту проблему полностью решает `gzip`, который отлично сжимает повторяющиеся последовательности и сводит минус на нет.
* Длинные имена классов писать долго. С этой проблемой помогают справиться автокомплит в редакторе и инструментарий, который автоматически добавляет префиксы (CSS-препроцессоры и шаблонизаторы).

Мы считаем, что затраты времени, необходимые на написание длинных имен классов, намного меньше, чем на обдумывание архитектуры.

Применение правил по именованию, предложенных БЭМ-методолгией, позволяет:

* задать четкие связи между разными сущностями;
* определить типы сущностей по их именам;
* упростить восприятие кода.

Помимо всего вышеперечисленного, использование методологии БЭМ дает возможность получить **самодокументируемый код** вашего проекта.

<a name="bem-clarify-code"></a>
#### Самодокументируемый код

Большинство разработчиков сталкивались с переходом на новый проект, который уже какое-то время жил своей жизнью и успел накопить тысячи строк кода, но, как чаще всего бывает, не успел обзавестись подробной документацией.

В поддержке кода важно минимизировать время, которое разработчик тратит на то, чтоб понять, как все устроено, где что лежит и как вообще это работает. Порой именно на такое изучение уходит большая часть времени, а вовсе не на реализацию функциональности или исправление ошибки.

Одна из целей БЭМ — рассказать другим разработчикам как можно больше о том, что делает тот или иной код, по названиям классов в разметке. Читая HTML с небольшим количеством классов внутри, вы можете увидеть взаимодействие во всем коде и между его частями; что-то может быть независимым блоком, что-то дочерним компонентом — элементом этого блока, а что-то может видоизменять блок или элемент — модификатор блока или элемента.

Используя соглашения об именовании сущностей, разработчик сразу сможет понять всю анатомию блока:

* о каком блоке идет речь, и какую часть интерфейса он реализует;
* из каких частей (элементов или других блоков) он состоит;
* каким изменениям он подвергся благодаря тем или иным модификаторам.

Давайте рассмотрим пример с формой поиска на сайте. Попробуем прочитать только CSS и понять, что за форму он описывает.

Для начала представим как бы такая форма могла быть реализована в классическом программировании:

```css
form {}

input
{
    bacground: red;
}

input [type=submit]
{
    background: buttonface
}
```

Такая форма записи не дает разработчику никаких сведений о взаимодействии компонентов: невозможно определить, к чему относятся данные селекторы. Использование глобальных переменных для создания правил в CSS делают код проекта нерасширяемым — при попытке рефакторинга многие правила будут поломаны.

Попытаемся немного улучшить данный код — напишем CSS на классы:

```css
.form {}
.field {}
.submit {}
```

Код стал немного информативнее, но он все еще не дает понять, относится ли поле (`field`) к форме (`form`) или что произойдет, если полей или форм на странице будет несколько.

Перепишем пример, используя БЭМ:

```css
.form {}
.form_search {}
.form__field {}
.form__submit-button {}
```

Такая запись дает полное понимание того, как работает данный код. Только из имен CSS-классов видно, что:

* Существует некий блок `form`.
* Форма здесь пердставлена уже не просто как абстрактная сущность: благодаря мофификатору `form_search` можно понять, что речь идет о форме поиска.
* У этой формы есть вложенные элементы: поле `form__field` и кнопка `form__submit-button`.

Такое именование сущностей позволяет понять структуру блока на странице без подробного изучения HTML. Даже если на странице будет еще одно поле `field`, то его правила никак не будут влиять на поле, описанное в поисковой форме.

Жесткие правила именования в БЭМ позволяют сделать код вашего проекта прозрачным, однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков и идеально подходит для крупных проектов и больших команд. Не прилагая дополнительных усилий вы получаете самодокументируемый код.

<a name="bem-split-code"></a>
### Меняем CSS-правила одного компонента страницы и при этом не ломаем другие

Описывая страницу, зачастую оперируют одними и теми же понятиями: всевозможные пункты могут встречаться в совершенно различных ситуациях, ссылок на странице может быть множество, при этом какие-то из них должны уводить читателя на другую страницу, какие-то просто облегчать навигацию по странице.

Вернемся к примеру с навигационным меню:

```html
<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

CSS-стили к пункту `item` в нем скорее всего будут записаны как:

```css
.item
{
    padding: 4px 10px;
    color: black;
}
```

Если на страницу понадобится добавить дополнительные компоненты, включающие в себя пункты, то появиться еще один блок кода, содержащий класс `item`, например:

```html
<div class="snippets">
    <div class="item">
        <div class="title"></div>
        <img class="thumb">
    </div>
</div>
```

Вероятность того, что CSS-правила будут оформлены с помощью каскада возрастает, не зря ведь CSS назван Cascading Style Sheets.

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.snippets.item
{
    color: red;
    font-size: 14px;
}
```

Такой подход кажется вполне удобным и логичным: необходимо просто доопределить правила, написанные для `item`.

> Проблема

Подобный код может совершенно безболезненно так существовать и работать до тех пор, пока не возникнет необходиомть изменить страницу, переместить какие-то пункты меню, использовать написанный код в другом месте отдельно от родителя.

Как только понадобится выполнить какое-то из вышеперечисленных действий, всплывет проблема того, что, казалось бы, независимые части кода слишком связаны и влияют друг на друга. Нет возможности исправить какой-то один компонент, не зацепив так или иначе стили другого.

Изменения стилей одного компонента страницы, могут вызвать неожиданный «сюрприз» в виде сломанного зависимого компонента в другой части проекта.

> Решение

Правила по именованию CSS-селекторов в БЭМ дают возможность вносить изменения точечно, не ломая зависимые компоненты. В БЭМ каждый компонент имеет уникальное имя и является самодостаточным.

Запишем тот же код в соответствии с правилами именования БЭМ:

```html
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

```css
.nav
{
    font-size: 12px;
}

.nav__item
{
    padding: 4px 10px;
    color: black;
}

.nav__link
{
    color: blue;
    text-decoration: underline;
}
```

В таком случае добавление нового пункта на страницу ничего не сломает — у пункта `snippets` появится свое специфичное имя `snippets__item`.

```html
<div class="snippets">
    <div class="snippets__item">
        <div class="snippets__title"></div>
        <img class="snippents__thumb" />
    </div>
</div>
```

Пункт `snippets__item` будет иметь соответсвующие только ему уникальные CSS-правила:

```css
.snippets__item
{
    padding: 4px 10px;
    color: red;
    font-size: 14px;
}
```

Внесенные изменения в `nav__item` никак не отобразятся на пункте `snippets__item`.

Прозрачное именование блоков, элементов и модификаторов и уход от каскадов позволят вносить изменения только в конкретные компоненты и иметь четкое представление, к какому блоку относится каждый элемент и какие стили могут на него влиять.

Таким образом, элемент `item` получает уникальные независимые CSS-стили благодаря неймспейсам в виде имен блоков. Такой подход дает возможность защитить элементы от взаимного влияния друг на друга — элементы всегда располагаются внутри блока. По такому же принципу работает Shadow Dom в Web Components. Но, в отличие от Shadow Dom, использование БЭМ-нотации не зависит от поддержки браузеров  и не привязываются к конкретному API.

Блоки `snippets` и `nav` содержат в себе можно повторно использовать на других страницах или в другом проекте.

Независимость блоков касается не только CSS. В методологии БЭМ блок является абсолютно независимой и самодостаточной единицей. Он знает о себе все: свой внешний вид (CSS), поведение (JavaScript) и шаблоны и перечень блоков, с которыми ему необходимо взаимодействовать (зависимости).

// сослаться на док «Зачем БЭМ в JavaScript»

Уникальность имен классов, основанная на правилах именования БЭМ, позволяет блокам не зависеть друг от друга.

#### Использование каскадов в БЭМ

Из предыдущей главы может сложиться впечатление, что методология БЭМ полностью отрицает использование каскада. Это не совсем так — каскады в БЭМ существуют, но встречаются значительно реже.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока (`.nav_hovered .nav__link { text-decoration: underline; }`) или, скажем, темы (`.nav_theme_islands .nav__item { line-height: 1.5; }`).

Но в случае использования каскада повышается вероятность связанности кода, что делает его повторное использование невозможным и увеличивает риски попасть в ситуацию, когда переписать проще, чем исправить.

### Миксы или как разместить несколько сущностей на одном DOM-узле

Воспользуемся еще раз нашим примером, который реализует универсальный блок навигационного меню. Такой блок можно использовать в совершенно различных случаях.

```
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

Но может возникнуть необходимость применить его в составе нового блока. Допустим, отображать с его помощью какие-то статьи в блоке новостей. В таком случае воздействовть на блок `nav` с помощью модификатора — не самый хороший выбор, так как семантически `nav` будет уже принципиально другим блоком — блоком новостей.

Решить такую задачу можно при помощи [микса]() двух блоков. То есть смешать на одном DOM-узле два разных блока: блок `nav` и `articles`.

```html
<ul class="nav articles">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

При этом такая реализация будет содержать всю функциаональность блока `nav`, а также особенности реализации блока `articles`.

Точно также можно смешивать блоки с элементами [и не только](ссылка на difinitions в раздел).

Снова вернемся к нашему примеру. В нем используется ссылка в качестве элемента блока `nav` — `nav__link`. Но в проекте ссылка может быть и отдельным блоком.

Например, в проекте все ссылки изначально были одинаковые. Существует блок `link` и прописанные ему CSS-свойства `.link { color: blue; }`. Но затем появляется необходимость сделать все ссылки в навигационном меню шапки немного больше и заметнее.

В такой ситуации также удобно воспользоваться миксом — в этот раз смешать на одном DOM-узле блоков и элемент другого блока. В нашем случае это будет блок `link` и элемент `nav__link`.

Не нужно создавать еще один блок, можно просто добавить специфические правила для ссылки, актуальные только навигационному меню, расположенному в шапке:

```
.nav__link
{
   font-size: 14px;
   font-weight: bold;
}
```

Для того, чтобы стили `nav__link` применились к ссылкам в меню, нужно просто подмешать к блоку `link` элемент `nav__link`.

Пример вполне может выглядеть так:

```html
<ul class="nav">
    <li class="nav__item">
        <a class="link nav__link"></a>
    </li>
</ul>
```

При этом все общее, что есть у всех ссылок в проекте, будет описано в блоке `link`, а особенности, присущие только ссылке внутри `nav`, в `nav__link`.

<a href="bem-fast"></a>
### Скорость рендеринга и селекторы большой вложенности в CSS

сократить в два раза -ссылки читаются справа налево

Как уже говорилось выше применение каскада в CSS вполне оправдано в случае стандартного подхода к разработке, но использование селекторов большой вложенности может значительно снизить быстродействие вашего сайта.

Конечно, на маленьких и средних страницах CSS не может сильно влиять на скорость. Однако, если ваш проект растет (а большинство разработчиков стремятся именно к этому), вы уже не можете не учитывать этот фактор, влияющий на скорость. К тому времени, когда вы осознаете, что CSS замедляет работу проекта, будет очень сложно или практически невозможно начинать оптимизацию CSS-правил.

> Решение

Правила именования в БЭМ созданы таким образом, что каждый БЭМ-класс имеет уникальное имя и является самодостаточным – разные блоки никогда не пересекаются по именам классов.

Это означает, что вам, скорее всего, достаточно указать один класс, чтобы:

* описать стили самого блока;
* описать стили любого элемента внутри блока;
* добавить дополнительные стили или переопределения с помощью модификатора.

Большинство браузеров начинают применять селектор с «правой части» (охватывающей чаще всего большее множество узлов) и затем уточняют полученную выборку, фильтруя ее применением оставшихся правил. Чем больше шагов фильтрации требуется, тем больше времени это занимает. Современные браузеры очень хорошо оптимизированы для этих задач, но последние версии установлены далеко не у всех, и мобильные устройства всегда могут вести себя иначе — а селекторы, состоящие из одного класса, как минимум относятся к самым быстрым селекторам из всех возможных.

Конечно же БЭМ не отменяет каскад в CSS! Однако он значительно сокращает его использование. Существуют сложные случаи, когда необходимо указать два и более классов в одном селекторе. Например, сочетание модификаторов, внутренние зависимости элементов или влияние модификатора блока на стили отдельных его элементов:

```
.menu-item_disabled .menu-item__label
{
   display: none;
}
```

Но поскольку БЭМ превращает CSS из простого набора классов в семантическую модель проекта, то скорее всего потребность переопределить заданные стили будет зависеть от модификатора, который, как и положено в БЭМ, будет иметь свою уникальное имя. Таким образом нам удается сохранить специфичность CSS-правил.





<a name="name-scheme"></a>
### Распространенные схемы именования по БЭМ

**Классический стиль**

`block-name__elem-name_mod-name_mod-val`

Использование описано в предыдущей главе. Данный стиль имеет один существенный плюс – все предлагаемые инструменты [платформы БЭМ](), в том числе и с открытыми исходниками, ориентируются именно на такое именование.

**Стиль [Гарри Робертса](на статью)**

такой-то такой-то в своей статье

`block-name__elem-name--mod-name`

* использование дефиса в именах;
* отделение имени элемента от блока с помощью двух подчеркиваний;
* отделение булевых модификаторов с помощью двух дефисов;
* модификаторы вида «ключ-значение» не используются.

**Стиль без подчеркиваний**

`blockName-elemName--modName-modVal`

* использование в именах «верблюжего регистра»;
* отделение имени элемента от блока с помощью одного дефиса;
* отделение модификаторов с помощью двух дефисов;
* отделение значения модификатора с помощью одного дефиса.

**модификатор без имени блока**

__available

плохо потому что при использовании миксов невозможно отличить к какому блоку относиться мод

Верблюжий регистр

отдеьное свойство

Выводы

Возмоность мыслить и работать на уровне сущностей и не слишком зависеть при этом от структуры страницы позволила разбить содержимое на логические блоки и сделать их независимыми друг от друга.

Основная идея схожа с принципами ООП — иметь возможность создать ограниченное число повторно используемых компонентов. Такой подход позволяет создавать более надежные, гибкие и пригодные для повторного использования компоненты.


Такой подход позволит создавать проекты

Разделение на блоки (модульный подход) позволяет легче распараллеливать разработку, и защищает от ситуации «единоличного контроля» разработчика над важной частью проекта, поскольку сам БЭМ-подход поощряет модульность. Кроме этого, в любом самом сложном коде базовые приёмы работы с данными будут одинаковыми; разбираться в таком коде проще, поддерживать его — легче.


//
мы устанавливаем связи между элементами за счет одного только именования классов
