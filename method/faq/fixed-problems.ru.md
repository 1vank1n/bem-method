# Типичные проблемы веб-разработчика и способы их решения с БЭМ

БЭМ-методология задает ряд [правил по именованию CSS-селекторов](../naming/naming.ru.md), соблюдение которых решает следующие проблемы веб-разработки:

* [Как уменьшить сложность кода и упростить рефакторинг](#bem-simple-code)
* [Как определить типы сущности в отрыве от контекста и получить самодокументируемый код](#bem-clarify-code)
* [Как начать повторно использовать код и избежать взаимного влияния компонентов друг на друга](#bem-split-code)
* [Как разместить несколько сущностей на одном DOM-узле и забыть про «копипаст»](#bem-mix)

<a name="bem-simple-code"></a>
## Как уменьшить сложность кода и упростить рефакторинг

**Проблема**

Распространенная ситуация: при разработке проекта все компоненты интерфейса получают имена на основе личных предпочтений и опыта разработчика.

Например, для создания простого навигационного меню могут использоваться следующие имена классов:

```html
<ul class="nav">
    <li class="item active"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

К ним могут быть написаны CSS-правила:

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

Предположим, что нужно в навигационном меню изменить правила для класса `.active`.

В активной стадии развития проекта разработчик может помнить и вовремя отслеживать все компоненты, которые используют класс `.active`. Но при переходе между проектами или при необходимости долгосрочной поддержки, возрастает вероятность упустить все существующие зависимости. По имени класса `.active` невозможно проследить наличие использующих его компонентов.
Может оказаться, что на других страницах существует, например, `.link.active`. В таком случае изменение правил для `.active` могут вызвать нежелательные «сюрпризы» в `.link.active`.

Чтобы разобраться, можно ли безболезненно изменить стили для `.active`, разработчику придется просмотреть всю структуру страницы или проекта. Любое изменение потребует значительных временных затрат только на поиск зависимых компонентов.

**Решение**

Методология БЭМ помогает отслеживать связи между компонентами в пределах проекта при помощи [соглашения по именованию CSS-классов](../naming/naming.ru.md).

Рассмотрим этот же пример, но уже с примененными правилами именования БЭМ: класс `nav` будет обозначать имя блока, `nav__item` — имя элемента, а `nav__item_active` — имя его модификатора.

В таком случае запись будет следующей:

```html
<ul class="nav">
    <li class="nav__item nav__item_active"><a class="nav__link">One</a></span></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

И, соответственно, CSS будет иметь такой вид:

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}

.nav__item_active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

Новые имена CSS-классов содержат всю информацию о структуре блока, исключая необходимость заглядывать в HTML-код страницы. Cелектор всегда содержит знания о том, на какой блок или элемент влияют его правила (в данном случае на элемент `nav__item`). Разработчику не придется думать о возможном существовании `.link.active`, так как его CSS-правила по БЭМ-методологии будут записаны как `.link_active` и не будут зависеть от правил модификатора `active` для пункта меню (`nav__item_active`).

>Такой подход имеет два потенциальных минуса:

>* Результирующий код весит больше. Эту проблему полностью решает `gzip`, который сжимает повторяющиеся последовательности и сводит минус на нет.
>* Длинные имена классов писать долго. С этой проблемой помогают справиться автозаполнение в редакторе и инструментарий, который автоматически добавляет префиксы (CSS-препроцессоры и шаблонизаторы).

>Однако затраты времени, необходимые на написание длинных имен классов, намного меньше, чем на обдумывание архитектуры.

Применение правил по именованию, предложенных БЭМ-методолгией, позволяет:

* задавать явные связи между разными сущностями;
* упрощать восприятие кода.

Помимо всего вышеперечисленного, использование методологии БЭМ дает возможность получить **самодокументируемый код** проекта без дополнительных усилий.

<a name="bem-clarify-code"></a>
### Самодокументируемый код

**Проблема**

В поддержке кода важно минимизировать время, которое разработчик тратит на то, чтоб понять, как все устроено, где что лежит и как работает. Порой именно на такое изучение уходит большая часть времени, а вовсе не на реализацию функциональности или исправление ошибки.

**Решение**

Одна из целей БЭМ — дать понять, что делает тот или иной код, только по названиям классов в разметке. Идея самодокументируемого кода заключается в том, чтобы при просмотре названий CSS-классов, переменных и функций было понятно, как работает код, и как взаимодействуют компоненты интерфейса.

Используя БЭМ, можно получить HTML с небольшим количеством классов внутри и увидеть взаимодействие отдельных компонентов кода: что-то может быть независимым [блоком](../definitions/definitions.ru.md#bem-block), что-то дочерним компонентом — [элементом](../definitions/definitions.ru.md#bem-elem) этого блока, а что-то может видоизменять блок или элемент — [модификатор]](../definitions/definitions.ru.md#bem-mod).

Рассмотрим пример с формой поиска на сайте. Не будем обращаться к HTML, попробуем прочитать только CSS и понять, какую часть интерфейса он описывает.

Для начала представим как бы форма могла быть реализована в классической верстке:

```css
form {}

input
{
    bacground: red;
}

input[type=submit]
{
    background: buttonface
}
```

Такой способ записи не дает разработчику никаких сведений о взаимодействии компонентов: невозможно определить, к чему относятся данные селекторы. А использование глобальных селекторов делает код проекта нерасширяемым, так как внесение минимальных изменений повлечет за собой правки во всех зависимых правилах.

Попытаемся немного изменить данный код — напишем CSS на классы:

```css
.form {}
.field {}
.submit {}
```

Код стал информативнее: теперь понятно, что есть форма, поле и какой-то компонент `submit`. Но такие имена все еще не дают понять, относится ли поле (`field`) к форме (`form`), или что произойдет, если полей или форм на странице будет несколько. Снова возникает необходимость обращаться к HTML.

Перепишем пример, используя БЭМ:

```css
.form {}
.form_search {}
.form__field {}
.form__submit-button {}
```

Такая запись дает полное понимание того, как работает данный код. Только из имен CSS-классов видно, что:

* Существует некая форма, реализованная блоком `form`.
* Форма представлена уже не просто как абстрактная сущность: модификатор `form_search` указывает на то, что речь идет о форме поиска.
* У формы есть составляющие — вложенные элементы: поле `form__field` и кнопка `form__submit-button`.

Следование [соглашению по именованию сущностей](../naming/naming.ru.md) БЭМ позволяет понять структуру блока без подробного изучения HTML. Даже при наличии на странице еще одно поля `field`, его правила никак не будут влиять на поле, описанное в поисковой форме, так как оно будет реализовано, как элемент нового блока и будет иметь свое специфичное имя. Например, `attach__field`.

Правила именования в БЭМ позволяют сделать код вашего проекта однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков: не прилагая дополнительных усилий вы получаете самодокументируемый код.

<a name="bem-split-code"></a>
## Как начать повторно использовать код и избежать взаимного влияния компонентов друг на друга

**Проблема**

Для описания страницы часто используются одни и те же сниппеты (snippets). Например, ссылок на странице может быть множество, при этом какие-то из них должны уводить читателя на другой ресурс, какие-то просто облегчать навигацию по странице.

Чтобы наглядно показать проблему, рассмотрим пример с навигационным меню:

```html
<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

CSS-стили к пункту `item` в нем, скорее всего, будут записаны как:

```css
.item
{
    padding: 4px 10px;
    color: black;
}
```

Если на страницу понадобится добавить дополнительные компоненты, содержащие пункты, то появится еще один блок кода с классом `item`, например:

```html
<div class="snippets">
    <div class="item">
        <h2 class="title"></h2>
        <img class="thumb">
    </div>
</div>
```

Вероятность того, что CSS-правила будут оформлены с помощью каскада возрастает, не зря ведь CSS назван Cascading Style Sheets. Такой подход кажется вполне удобным и логичным: необходимо просто доопределить правила, уже написанные для `item`:

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.snippets .item
{
    color: red;
    font-size: 14px;
}
```

Подобный код может безболезненно существовать и работать до тех пор, пока не возникнет необходимость изменить страницу. Например, переместить какие-то пункты меню, использовать написанный код в другом месте отдельно от родительского компонента или вложить навигационное меню в `snippets`.

При попытке осуществить хотя бы одно из таких действий, разработчик столкнется с проблемой, что на первый взгляд независимые части кода слишком связаны и влияют друг на друга. Используя каскады, нет возможности исправить один компонент, не затронув так или иначе стили другого.

**Решение**

[Правила по именованию CSS-селекторов](..naming/naming.ru.md) в БЭМ дают возможность вносить изменения точечно, не ломая зависимые компоненты. В БЭМ каждый компонент имеет уникальное имя и является самодостаточным.

Запишем тот же код в соответствии с правилами именования БЭМ:

```html
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}
```

В таком случае добавление нового пункта `item` на страницу будет выглядеть так:

```html
<div class="snippets">
    <div class="snippets__item">
        <h2 class="snippets__title"></h2>
        <img class="snippents__thumb">
    </div>
</div>
```

Пункт `snippets__item` будет иметь соответствующие только ему уникальные CSS-правила:

```css
.snippets__item
{
    padding: 4px 10px;
    color: red;
    font-size: 14px;
}
```

Внесенные изменения в `nav__item` никак не отобразятся на пункте `snippets__item`.

Таким образом, элемент `item` получает уникальные независимые CSS-стили благодаря [неймспейсам](..) в виде имен блоков. Такой подход дает возможность защитить элементы от взаимного влияния друг на друга, так как они всегда являются частью блока. Такой же принцип работы использует и Shadow DOM в Web Components. Но, в отличие от Shadow DOM, применение БЭМ-нотации не зависит от поддержки браузеров.

В таком виде блоки `snippets` и `nav` можно повторно использовать и перемещать по странице или проекту. Уникальность имен классов, основанная на правилах именования БЭМ, позволяет блокам не зависеть друг от друга.

Независимость блоков касается не только CSS. В БЭМ блок является абсолютно самодостаточной единицей. Он знает о себе все: свой внешний вид (CSS), поведение (JavaScript) и шаблоны и перечень блоков, с которыми ему необходимо взаимодействовать (зависимости).

### Использование каскадов в БЭМ

Из предыдущей главы может сложиться впечатление, что методология БЭМ полностью отрицает каскады в CSS. Это не совсем так — каскады в БЭМ существуют, но встречаются значительно реже.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока или примененной к нему темы.

Например:

```
.nav_hovered .nav__link
{
    text-decoration: underline;
}
```

```
.nav_theme_islands .nav__item
{
    line-height: 1.5;
}
```

В случае использования каскада повышается вероятность связанности кода, что делает его повторное использование невозможным и увеличивает риски попасть в ситуацию, когда переписать проще, чем исправить.

<a name="bem-mix"></a>
## Миксы, или как разместить несколько сущностей на одном DOM-узле и избежать «копипаста»

**Проблема**

В любых проектах возникают ситуации, когда можно применить уже реализованную функциональность для создания другого компонента.

В классической веб-разработке такую проблему решают копированием нужной части кода в новый компонент. Такой подход имеет два минуса:

* увеличивается кодовая база проекта;
* затрудняется отладка кода при выявлении ошибки.

Разработчик вынужден поддерживать большее количество строк кода, вносить правки в каждую отдельную реализацию, что увеличивает временные затраты на отладку проекта.

**Решение**

Воспользуемся еще раз нашим примером, который реализует универсальный блок навигационного меню по всем [правилам именования БЭМ](../naming/naming.ru.md).

```
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

Такой блок можно использовать в совершенно различных случаях. Например, может возникнуть необходимость отображать с его помощью статьи в блоке новостей.

Допустим, в проекте уже есть блок `articles`, который реализован с помощью плиточного дизайна. В таком случае воздействовать на блок `nav` с помощью модификаторов — не самый хороший выбор, так как семантически `nav` будет уже принципиально другим блоком — блоком новостей. К тому же, создавая новый модификатор, придется копировать все правила, которые уже прописаны блоку `articles`, а этого хочется избежать.

Решить такую задачу можно при помощи [микса](../definitions/definitions.ru.md#bem-mix) двух блоков. То есть смешать на одном DOM-узле два разных блока: блок `nav` и `articles`.

В коде это будет выглядеть так:

```html
<ul class="nav articles">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

Такая реализация будет содержать всю функциональность блока `nav` и особенности реализации блока `articles` — внешний вид новостных статей в меню. При этом нет необходимости копировать уже имеющиеся правила. А при обнаружении ошибки, правки необходимо будет внести только в одну часть кода.

>Точно также миксовать можно не только блоки, но и другие БЭМ-сущности (элементы, модификаторы). Подробнее о вариантах использования миксов в БЭМ читайте в разделе [Определения](../definitions/definitions.ru.md#bem-mix).
